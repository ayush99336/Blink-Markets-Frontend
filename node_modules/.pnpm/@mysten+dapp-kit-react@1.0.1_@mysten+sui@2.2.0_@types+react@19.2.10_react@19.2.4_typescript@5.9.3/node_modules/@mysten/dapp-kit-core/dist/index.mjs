import { atom, computed, map, onMount, readonlyType, task } from "nanostores";
import { ReadonlyWalletAccount, StandardConnect, StandardDisconnect, StandardEvents, SuiSignAndExecuteTransaction, SuiSignAndExecuteTransactionBlock, SuiSignPersonalMessage, SuiSignTransaction, SuiSignTransactionBlock, WALLET_STANDARD_ERROR__FEATURES__WALLET_ACCOUNT_CHAIN_UNSUPPORTED, WalletStandardError, getWallets } from "@mysten/wallet-standard";
import { getWalletAccountFeature, getWalletFeature, uiWalletAccountBelongsToUiWallet, uiWalletAccountsAreSame } from "@wallet-standard/ui";
import { getOrCreateUiWalletAccountForStandardWalletAccount_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, getOrCreateUiWalletForStandardWallet_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, getWalletAccountForUiWalletAccount_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, getWalletForHandle_DO_NOT_USE_OR_YOU_WILL_BE_FIRED } from "@wallet-standard/ui-registry";
import { Transaction } from "@mysten/sui/transactions";
import { bcs } from "@mysten/sui/bcs";
import { fromBase64, toBase64 } from "@mysten/utils";
import { extractStatusFromEffectsBcs, parseTransactionBcs, parseTransactionEffectsBcs } from "@mysten/sui/client";
import { registerSlushWallet } from "@mysten/slush-wallet";
import { Ed25519Keypair } from "@mysten/sui/keypairs/ed25519";

//#region src/utils/errors.ts
var DAppKitError = class extends Error {};
/**
* Thown when someone attempts to perform an action that requires an active wallet connection.
*/
var WalletNotConnectedError = class extends DAppKitError {};
/**
* Thown when an account tries to invoke a feature on a chain that doesn't support it.
*/
var ChainNotSupportedError = class extends DAppKitError {};
/**
* Thown when an account tries to invoke a feature that it doesn't support.
*/
var FeatureNotSupportedError = class extends DAppKitError {};
/**
* Thown when a wallet is connected but no accounts are authorized.
*/
var WalletNoAccountsConnectedError = class extends DAppKitError {};
/**
* Thown when an account can't be found for a specific wallet.
*/
var WalletAccountNotFoundError = class extends DAppKitError {};

//#endregion
//#region src/utils/networks.ts
function getChain(network) {
	return `sui:${network}`;
}
function createNetworkConfig(networks, createClient) {
	if (networks.length === 0) throw new DAppKitError("You must specify at least one Sui network for your application.");
	const networkConfig = /* @__PURE__ */ new Map();
	function getClient(network) {
		if (networkConfig.has(network)) return networkConfig.get(network);
		const client = createClient(network);
		networkConfig.set(network, client);
		return client;
	}
	return {
		networkConfig: Object.freeze(networkConfig),
		getClient
	};
}

//#endregion
//#region src/utils/wallets.ts
const requiredWalletFeatures = [StandardConnect, StandardEvents];
const signingFeatures = [SuiSignTransaction, SuiSignTransactionBlock];
function getAssociatedWalletOrThrow(account, wallets) {
	const wallet = wallets.find((wallet$1) => uiWalletAccountBelongsToUiWallet(account, wallet$1));
	if (!wallet) throw new DAppKitError(`Wallet not found for account ${account.address}.`);
	return wallet;
}
function getWalletUniqueIdentifier(walletHandle) {
	const underlyingWallet = getWalletForHandle_DO_NOT_USE_OR_YOU_WILL_BE_FIRED(walletHandle);
	return underlyingWallet.id ?? underlyingWallet.name;
}
function getAccountFeature({ account, featureName, chain }) {
	if (!account.chains.includes(chain)) {
		const cause = new WalletStandardError(WALLET_STANDARD_ERROR__FEATURES__WALLET_ACCOUNT_CHAIN_UNSUPPORTED, {
			chain,
			featureName,
			supportedChains: [...account.chains],
			supportedFeatures: [...account.features],
			address: account.address
		});
		throw new ChainNotSupportedError(`The account ${cause.context.address} does not support the chain "${cause.context.chain}".`, { cause });
	}
	try {
		return getWalletAccountFeature(account, featureName);
	} catch (error) {
		throw new FeatureNotSupportedError(`The account ${account.address} does not support the feature "${featureName}".`, { cause: error });
	}
}
function tryGetAccountFeature(...args) {
	try {
		return getAccountFeature(...args);
	} catch (error) {
		if (error instanceof FeatureNotSupportedError) return null;
		throw error;
	}
}

//#endregion
//#region src/core/store.ts
function createStores({ defaultNetwork, getClient }) {
	const $baseConnection = map({
		status: "disconnected",
		currentAccount: null
	});
	const $currentNetwork = atom(defaultNetwork);
	const $registeredWallets = atom([]);
	const $compatibleWallets = computed([$registeredWallets, $currentNetwork], (wallets, currentNetwork) => {
		return wallets.filter((wallet) => {
			const areChainsCompatible = wallet.chains.some((chain) => getChain(currentNetwork) === chain);
			const hasRequiredFeatures = requiredWalletFeatures.every((featureName) => wallet.features.includes(featureName));
			const canSignTransactions = signingFeatures.some((featureName) => wallet.features.includes(featureName));
			return areChainsCompatible && hasRequiredFeatures && canSignTransactions;
		});
	});
	return {
		$currentNetwork,
		$registeredWallets,
		$compatibleWallets,
		$baseConnection,
		$currentClient: computed($currentNetwork, getClient),
		$connection: computed([$baseConnection, $compatibleWallets], (connection, wallets) => {
			switch (connection.status) {
				case "connected": return {
					wallet: getAssociatedWalletOrThrow(connection.currentAccount, wallets),
					account: connection.currentAccount,
					status: connection.status,
					supportedIntents: connection.supportedIntents,
					isConnected: true,
					isConnecting: false,
					isReconnecting: false,
					isDisconnected: false
				};
				case "connecting": return {
					wallet: null,
					account: connection.currentAccount,
					status: connection.status,
					supportedIntents: [],
					isConnected: false,
					isConnecting: true,
					isReconnecting: false,
					isDisconnected: false
				};
				case "reconnecting": return {
					wallet: getAssociatedWalletOrThrow(connection.currentAccount, wallets),
					account: connection.currentAccount,
					status: connection.status,
					supportedIntents: connection.supportedIntents,
					isConnected: false,
					isConnecting: false,
					isReconnecting: true,
					isDisconnected: false
				};
				case "disconnected": return {
					wallet: null,
					account: connection.currentAccount,
					status: connection.status,
					supportedIntents: [],
					isConnected: false,
					isConnecting: false,
					isReconnecting: false,
					isDisconnected: true
				};
				default: throw new Error(`Encountered unknown connection status: ${connection}`);
			}
		})
	};
}

//#endregion
//#region src/core/initializers/registered-wallets.ts
/**
* Handles updating the store in response to wallets being added, removed, and their properties changing.
*/
function syncRegisteredWallets({ $registeredWallets }) {
	onMount($registeredWallets, () => {
		const walletsApi = getWallets();
		const unsubscribeCallbacksByWallet = /* @__PURE__ */ new Map();
		const onWalletsChanged = () => {
			const wallets = walletsApi.get();
			$registeredWallets.set(wallets.map(getOrCreateUiWalletForStandardWallet_DO_NOT_USE_OR_YOU_WILL_BE_FIRED));
		};
		const subscribeToWalletEvents = (wallet) => {
			const unsubscribeFromChange = wallet.features[StandardEvents].on("change", () => {
				onWalletsChanged();
			});
			unsubscribeCallbacksByWallet.set(wallet, unsubscribeFromChange);
		};
		const unsubscribeFromRegister = walletsApi.on("register", (...addedWallets) => {
			addedWallets.filter(hasStandardEvents).forEach(subscribeToWalletEvents);
			onWalletsChanged();
		});
		const unsubscribeFromUnregister = walletsApi.on("unregister", (...removedWallets) => {
			removedWallets.filter(hasStandardEvents).forEach((wallet) => {
				const unsubscribeFromChange = unsubscribeCallbacksByWallet.get(wallet);
				if (unsubscribeFromChange) {
					unsubscribeCallbacksByWallet.delete(wallet);
					unsubscribeFromChange();
				}
			});
			onWalletsChanged();
		});
		walletsApi.get().filter(hasStandardEvents).forEach(subscribeToWalletEvents);
		onWalletsChanged();
		return () => {
			unsubscribeFromRegister();
			unsubscribeFromUnregister();
			unsubscribeCallbacksByWallet.forEach((unsubscribe) => unsubscribe());
			unsubscribeCallbacksByWallet.clear();
		};
	});
}
function hasStandardEvents(wallet) {
	return StandardEvents in wallet.features;
}

//#endregion
//#region src/core/actions/connect-wallet.ts
function connectWalletCreator({ $baseConnection }, supportedNetworks) {
	/**
	* Prompts the specified wallet to connect and authorize new accounts for the current domain.
	*/
	return async function connectWallet({ wallet, account, ...standardConnectArgs }) {
		return await task(async () => {
			const isAlreadyConnected = $baseConnection.get().status === "connected";
			try {
				$baseConnection.setKey("status", isAlreadyConnected ? "reconnecting" : "connecting");
				const { accounts: suiAccounts, supportedIntents } = await internalConnectWallet(wallet, supportedNetworks, standardConnectArgs);
				if (!isAlreadyConnected && suiAccounts.length === 0) throw new WalletNoAccountsConnectedError("No accounts were authorized.");
				if (account && !uiWalletAccountBelongsToUiWallet(account, wallet)) throw new WalletAccountNotFoundError(`No account with address ${account.address} is authorized for ${wallet.name}.`);
				$baseConnection.set({
					status: "connected",
					currentAccount: account ?? suiAccounts[0],
					supportedIntents: supportedIntents ?? []
				});
				return { accounts: suiAccounts };
			} catch (error) {
				$baseConnection.setKey("status", isAlreadyConnected ? "connected" : "disconnected");
				throw error;
			}
		});
	};
}
async function internalConnectWallet(wallet, supportedNetworks, args) {
	const { connect } = getWalletFeature(wallet, StandardConnect);
	const result = await connect(args);
	const underlyingWallet = getWalletForHandle_DO_NOT_USE_OR_YOU_WILL_BE_FIRED(wallet);
	const supportedChains = supportedNetworks.map(getChain);
	const supportedIntents = result.supportedIntents ?? await getSupportedIntentsFromFeature(wallet);
	return {
		accounts: result.accounts.filter((account) => account.chains.some((chain) => supportedChains.includes(chain))).map(getOrCreateUiWalletAccountForStandardWalletAccount_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.bind(null, underlyingWallet)),
		supportedIntents
	};
}
async function getSupportedIntentsFromFeature(wallet) {
	if (!wallet.features.includes("sui:getCapabilities")) return [];
	return (await getWalletFeature(wallet, "sui:getCapabilities")?.getCapabilities())?.supportedIntents ?? [];
}

//#endregion
//#region src/core/initializers/autoconnect-wallet.ts
/**
* Attempts to connect to a previously authorized wallet account on mount and when new wallets are registered.
*/
function autoConnectWallet({ networks, stores: { $baseConnection, $compatibleWallets }, storage, storageKey }) {
	onMount($compatibleWallets, () => {
		return $compatibleWallets.listen(async (wallets, oldWallets) => {
			if (oldWallets && oldWallets.length > wallets.length) return;
			if ($baseConnection.get().status !== "disconnected") return;
			const savedWalletAccount = await task(() => {
				return getSavedWalletAccount({
					networks,
					storage,
					storageKey,
					wallets
				});
			});
			if (savedWalletAccount) $baseConnection.set({
				status: "connected",
				currentAccount: savedWalletAccount.account,
				supportedIntents: savedWalletAccount.supportedIntents
			});
		});
	});
}
async function getSavedWalletAccount({ networks, storage, storageKey, wallets }) {
	const savedWalletIdAndAddress = await storage.getItem(storageKey);
	if (!savedWalletIdAndAddress) return null;
	const [savedWalletId, savedAccountAddress, savedIntents] = savedWalletIdAndAddress.split(":");
	if (!savedWalletId || !savedAccountAddress) return null;
	const targetWallet = wallets.find((wallet) => getWalletUniqueIdentifier(wallet) === savedWalletId);
	if (!targetWallet) return null;
	const existingAccount = targetWallet.accounts.find((account$1) => account$1.address === savedAccountAddress);
	if (existingAccount) return {
		account: existingAccount,
		supportedIntents: (savedIntents ? savedIntents.split(",") : null) ?? await getSupportedIntentsFromFeature(targetWallet)
	};
	const { accounts: alreadyAuthorizedAccounts, supportedIntents } = await internalConnectWallet(targetWallet, networks, { silent: true });
	const account = alreadyAuthorizedAccounts.find((account$1) => account$1.address === savedAccountAddress);
	return account ? {
		account,
		supportedIntents
	} : null;
}

//#endregion
//#region src/utils/storage.ts
const DEFAULT_STORAGE_KEY = "mysten-dapp-kit:selected-wallet-and-address";
function getDefaultStorage() {
	return isLocalStorageAvailable() ? localStorage : createInMemoryStorage();
}
function createInMemoryStorage() {
	const store = /* @__PURE__ */ new Map();
	return {
		getItem(key) {
			return store.get(key) ?? null;
		},
		setItem(key, value) {
			store.set(key, value);
		},
		removeItem(key) {
			store.delete(key);
		}
	};
}
function isLocalStorageAvailable() {
	try {
		const testKey = "__storage_test__";
		localStorage.setItem(testKey, "test");
		localStorage.removeItem(testKey);
		return true;
	} catch {
		return false;
	}
}

//#endregion
//#region src/core/initializers/sync-state-to-storage.ts
/**
* Syncs the most recently connected wallet name and address to storage.
*/
function syncStateToStorage({ stores: { $connection }, storage, storageKey }) {
	onMount($connection, () => {
		return $connection.listen((connection, oldConnection) => {
			if (!oldConnection || oldConnection.status === connection.status) return;
			if (connection.account) storage.setItem(storageKey, getSavedAccountStorageKey(connection.account, connection.supportedIntents));
			else storage.removeItem(storageKey);
		});
	});
}
function getSavedAccountStorageKey(account, supportedIntents) {
	return `${getWalletUniqueIdentifier(account).replace(":", "_")}:${account.address}:${supportedIntents.join(",")}:`;
}

//#endregion
//#region src/core/initializers/manage-connection.ts
/**
* Handles updating the connection state in response to wallets and their properties changing.
*/
function manageWalletConnection({ $compatibleWallets, $baseConnection }) {
	onMount($compatibleWallets, () => {
		return $compatibleWallets.listen(async (wallets) => {
			const connection = $baseConnection.get();
			if (connection.status !== "connected") return;
			const resolvedAccount = resolveWalletAccount(connection.currentAccount, wallets);
			if (resolvedAccount) $baseConnection.setKey("currentAccount", resolvedAccount);
			else $baseConnection.set({
				status: "disconnected",
				currentAccount: null
			});
		});
	});
}
function resolveWalletAccount(currentAccount, wallets) {
	for (const wallet of wallets) {
		for (const walletAccount of wallet.accounts) if (uiWalletAccountsAreSame(currentAccount, walletAccount)) return walletAccount;
		if (uiWalletAccountBelongsToUiWallet(currentAccount, wallet) && wallet.accounts[0]) return wallet.accounts[0];
	}
	return null;
}

//#endregion
//#region src/core/actions/switch-network.ts
function switchNetworkCreator({ $currentNetwork }) {
	/**
	* Switches the currently selected network to the specified network.
	*/
	return function switchNetwork(network) {
		$currentNetwork.set(network);
	};
}

//#endregion
//#region src/core/actions/disconnect-wallet.ts
function disconnectWalletCreator({ $baseConnection, $connection }) {
	/**
	* Disconnects the current wallet from the application and prompts the current wallet
	* to deauthorize accounts from the current domain depending on the wallet's implemetation
	* of `standard:disconnect`.
	*/
	return async function disconnectWallet(...standardDisconnectArgs) {
		return await task(async () => {
			const { wallet } = $connection.get();
			if (!wallet) throw new WalletNotConnectedError("No wallet is connected.");
			try {
				const { disconnect } = getWalletFeature(wallet, StandardDisconnect);
				await disconnect(...standardDisconnectArgs);
			} catch (error) {
				console.warn("Failed to disconnect the current wallet from the application.", error);
			} finally {
				$baseConnection.set({
					status: "disconnected",
					currentAccount: null
				});
			}
		});
	};
}

//#endregion
//#region src/core/actions/switch-account.ts
function switchAccountCreator({ $baseConnection, $connection }) {
	/**
	* Switches the currently selected account to the specified account.
	*/
	return function switchAccount({ account }) {
		const { wallet } = $connection.get();
		if (!wallet) throw new WalletNotConnectedError("No wallet is connected.");
		if (!uiWalletAccountBelongsToUiWallet(account, wallet)) throw new WalletAccountNotFoundError(`No account with address ${account.address} is connected to ${wallet.name}.`);
		$baseConnection.setKey("currentAccount", account);
	};
}

//#endregion
//#region src/core/actions/sign-personal-message.ts
function signPersonalMessageCreator({ $connection, $currentNetwork }) {
	/**
	* Prompts the specified wallet account to sign a personal message.
	*/
	return async function signPersonalMessage({ ...standardArgs }) {
		const { account } = $connection.get();
		if (!account) throw new WalletNotConnectedError("No wallet is connected.");
		const chain = getChain($currentNetwork.get());
		return await getAccountFeature({
			account,
			chain,
			featureName: SuiSignPersonalMessage
		}).signPersonalMessage({
			...standardArgs,
			account: getWalletAccountForUiWalletAccount_DO_NOT_USE_OR_YOU_WILL_BE_FIRED(account),
			chain
		});
	};
}

//#endregion
//#region src/utils/transaction-result.ts
function buildTransactionResult(digest, signature, transactionBytes, effectsBytes) {
	const status = extractStatusFromEffectsBcs(effectsBytes);
	let effects = null;
	try {
		effects = parseTransactionEffectsBcs(effectsBytes);
	} catch {
		console.warn("Parsing transaction effects failed, you may need to update the SDK to pickup the latest bcs types");
	}
	const txResult = {
		digest,
		signatures: [signature],
		epoch: null,
		status,
		effects,
		transaction: parseTransactionBcs(transactionBytes),
		balanceChanges: void 0,
		events: void 0,
		objectTypes: void 0,
		bcs: transactionBytes
	};
	return status.success ? {
		$kind: "Transaction",
		Transaction: txResult
	} : {
		$kind: "FailedTransaction",
		FailedTransaction: txResult
	};
}

//#endregion
//#region src/core/actions/sign-and-execute-transaction.ts
function signAndExecuteTransactionCreator({ $connection, $currentClient }) {
	/**
	* Prompts the specified wallet account to sign and execute a transaction.
	*/
	return async function signAndExecuteTransaction({ transaction, ...standardArgs }) {
		const { account, supportedIntents } = $connection.get();
		if (!account) throw new WalletNotConnectedError("No wallet is connected.");
		const underlyingAccount = getWalletAccountForUiWalletAccount_DO_NOT_USE_OR_YOU_WILL_BE_FIRED(account);
		const suiClient = $currentClient.get();
		const chain = getChain(suiClient.network);
		const transactionWrapper = { toJSON: async () => {
			if (typeof transaction === "string") return transaction;
			transaction.setSenderIfNotSet(account.address);
			return await transaction.toJSON({
				client: suiClient,
				supportedIntents
			});
		} };
		const signAndExecuteTransactionFeature = tryGetAccountFeature({
			account,
			chain,
			featureName: SuiSignAndExecuteTransaction
		});
		if (signAndExecuteTransactionFeature) {
			const result = await signAndExecuteTransactionFeature.signAndExecuteTransaction({
				...standardArgs,
				account: underlyingAccount,
				transaction: transactionWrapper,
				chain
			});
			const transactionBytes = fromBase64(result.bytes);
			const effectsBytes = fromBase64(result.effects);
			return buildTransactionResult(result.digest, result.signature, transactionBytes, effectsBytes);
		}
		const signAndExecuteTransactionBlockFeature = tryGetAccountFeature({
			account,
			chain,
			featureName: SuiSignAndExecuteTransactionBlock
		});
		if (signAndExecuteTransactionBlockFeature) {
			const transactionBlock = Transaction.from(await transactionWrapper.toJSON());
			const { digest, rawEffects, rawTransaction } = await signAndExecuteTransactionBlockFeature.signAndExecuteTransactionBlock({
				account,
				chain,
				transactionBlock,
				options: {
					showRawEffects: true,
					showRawInput: true
				}
			});
			const [{ txSignatures: [signature], intentMessage: { value: bcsTransaction } }] = bcs.SenderSignedData.parse(fromBase64(rawTransaction));
			return buildTransactionResult(digest, signature, bcs.TransactionData.serialize(bcsTransaction).toBytes(), new Uint8Array(rawEffects));
		}
		throw new FeatureNotSupportedError(`The account ${account.address} does not support signing and executing transactions.`);
	};
}

//#endregion
//#region src/core/actions/sign-transaction.ts
function signTransactionCreator({ $connection, $currentClient }) {
	/**
	* Prompts the specified wallet account to sign a transaction.
	*/
	return async function signTransaction({ transaction, ...standardArgs }) {
		const { account, supportedIntents } = $connection.get();
		if (!account) throw new WalletNotConnectedError("No wallet is connected.");
		const underlyingAccount = getWalletAccountForUiWalletAccount_DO_NOT_USE_OR_YOU_WILL_BE_FIRED(account);
		const suiClient = $currentClient.get();
		const chain = getChain(suiClient.network);
		const transactionWrapper = { toJSON: async () => {
			if (typeof transaction === "string") return transaction;
			transaction.setSenderIfNotSet(account.address);
			return await transaction.toJSON({
				client: suiClient,
				supportedIntents
			});
		} };
		const signTransactionFeature = tryGetAccountFeature({
			account,
			chain,
			featureName: SuiSignTransaction
		});
		if (signTransactionFeature) return await signTransactionFeature.signTransaction({
			...standardArgs,
			transaction: transactionWrapper,
			account: underlyingAccount,
			chain
		});
		const signTransactionBlockFeature = tryGetAccountFeature({
			account,
			chain,
			featureName: SuiSignTransactionBlock
		});
		if (signTransactionBlockFeature) {
			const transaction$1 = Transaction.from(await transactionWrapper.toJSON());
			const { transactionBlockBytes, signature } = await signTransactionBlockFeature.signTransactionBlock({
				transactionBlock: transaction$1,
				account: underlyingAccount,
				chain
			});
			return {
				bytes: transactionBlockBytes,
				signature
			};
		}
		throw new FeatureNotSupportedError(`The account ${account.address} does not support signing transactions.`);
	};
}

//#endregion
//#region src/wallets/slush-web.ts
function slushWebWalletInitializer(config) {
	return {
		id: "slush-web-wallet-initializer",
		async initialize() {
			const result = await registerSlushWallet(config?.appName || getDefaultAppName(), {
				origin: config?.origin,
				metadataApiUrl: config?.metadataApiUrl
			});
			if (!result) throw new Error("Registration un-successful.");
			return { unregister: result.unregister };
		}
	};
}
function getDefaultAppName() {
	return document.querySelector(`meta[name="application-name"]`)?.content || document.title;
}

//#endregion
//#region src/wallets/index.ts
const initializerMap = /* @__PURE__ */ new Map();
async function registerAdditionalWallets(initializers, args) {
	initializerMap.forEach((unregister) => unregister());
	initializerMap.clear();
	const initializePromises = [...new Map(initializers.map((init) => [init.id, init])).values()].map(async (initializer) => {
		return {
			initializer,
			result: await initializer.initialize(args)
		};
	});
	const initializerResults = await Promise.allSettled(initializePromises);
	for (const settledResult of initializerResults) if (settledResult.status === "fulfilled") {
		const { initializer, result } = settledResult.value;
		initializerMap.set(initializer.id, result.unregister);
	} else console.warn(`Skipping wallet initializer: "${settledResult.reason}".`);
}

//#endregion
//#region src/wallets/unsafe-burner.ts
function unsafeBurnerWalletInitializer() {
	return {
		id: "unsafe-burner-initalizer",
		async initialize({ networks, getClient }) {
			const wallet = new UnsafeBurnerWallet({ clients: networks.map(getClient) });
			return { unregister: getWallets().register(wallet) };
		}
	};
}
var UnsafeBurnerWallet = class {
	#chainConfig;
	#keypair = new Ed25519Keypair();
	#account;
	constructor({ clients }) {
		this.#chainConfig = clients.reduce((accumulator, client) => {
			const chain = getChain(client.network);
			accumulator[chain] = client;
			return accumulator;
		}, {});
		this.#account = new ReadonlyWalletAccount({
			address: this.#keypair.getPublicKey().toSuiAddress(),
			publicKey: this.#keypair.getPublicKey().toSuiBytes(),
			chains: this.chains,
			features: [
				SuiSignTransaction,
				SuiSignAndExecuteTransaction,
				SuiSignPersonalMessage
			]
		});
		console.warn("Your application is currently using the unsafe burner wallet. Make sure that this wallet is disabled in production.");
	}
	get version() {
		return "1.0.0";
	}
	get name() {
		return "Unsafe Burner Wallet";
	}
	get icon() {
		return "data:image/png;base64,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";
	}
	get chains() {
		return Object.keys(this.#chainConfig);
	}
	get accounts() {
		return [this.#account];
	}
	get features() {
		return {
			[StandardConnect]: {
				version: "1.0.0",
				connect: this.#connect
			},
			[StandardEvents]: {
				version: "1.0.0",
				on: this.#on
			},
			[SuiSignPersonalMessage]: {
				version: "1.1.0",
				signPersonalMessage: this.#signPersonalMessage
			},
			[SuiSignTransaction]: {
				version: "2.0.0",
				signTransaction: this.#signTransaction
			},
			[SuiSignAndExecuteTransaction]: {
				version: "2.0.0",
				signAndExecuteTransaction: this.#signAndExecuteTransaction
			}
		};
	}
	#on = () => {
		return () => {};
	};
	#connect = async () => {
		return { accounts: this.accounts };
	};
	#signPersonalMessage = async (messageInput) => {
		return await this.#keypair.signPersonalMessage(messageInput.message);
	};
	#signTransaction = async ({ transaction, signal, chain }) => {
		signal?.throwIfAborted();
		const client = this.#chainConfig[chain];
		if (!client) throw new Error(`Invalid chain "${chain}" specified.`);
		const builtTransaction = await Transaction.from(await transaction.toJSON()).build({ client });
		return await this.#keypair.signTransaction(builtTransaction);
	};
	#signAndExecuteTransaction = async ({ transaction, signal, chain }) => {
		signal?.throwIfAborted();
		const client = this.#chainConfig[chain];
		if (!client) throw new Error(`Invalid chain "${chain}" specified.`);
		const parsedTransaction = Transaction.from(await transaction.toJSON());
		const bytes = await parsedTransaction.build({ client });
		const result = await this.#keypair.signAndExecuteTransaction({
			transaction: parsedTransaction,
			client
		});
		const tx = result.Transaction ?? result.FailedTransaction;
		return {
			bytes: toBase64(bytes),
			signature: tx.signatures[0],
			digest: tx.digest,
			effects: toBase64(tx.effects.bcs)
		};
	};
};

//#endregion
//#region src/core/index.ts
function createDAppKit({ autoConnect = true, networks, createClient, defaultNetwork = networks[0], enableBurnerWallet = false, slushWalletConfig, storage = getDefaultStorage(), storageKey = DEFAULT_STORAGE_KEY, walletInitializers = [] }) {
	const networkConfig = createNetworkConfig(networks, createClient);
	const stores = createStores({
		defaultNetwork,
		getClient: networkConfig.getClient
	});
	function getClient(network) {
		return network ? networkConfig.getClient(network) : stores.$currentClient.get();
	}
	storage ||= createInMemoryStorage();
	syncStateToStorage({
		stores,
		storageKey,
		storage
	});
	syncRegisteredWallets(stores);
	manageWalletConnection(stores);
	if (autoConnect) autoConnectWallet({
		networks,
		stores,
		storageKey,
		storage
	});
	registerAdditionalWallets([
		...walletInitializers,
		...enableBurnerWallet ? [unsafeBurnerWalletInitializer()] : [],
		...slushWalletConfig !== null ? [slushWebWalletInitializer(slushWalletConfig)] : []
	], {
		networks,
		getClient
	});
	return {
		networks,
		getClient,
		signTransaction: signTransactionCreator(stores),
		signAndExecuteTransaction: signAndExecuteTransactionCreator(stores),
		signPersonalMessage: signPersonalMessageCreator(stores),
		connectWallet: connectWalletCreator(stores, networks),
		disconnectWallet: disconnectWalletCreator(stores),
		switchAccount: switchAccountCreator(stores),
		switchNetwork: switchNetworkCreator(stores),
		stores: {
			$wallets: stores.$compatibleWallets,
			$connection: stores.$connection,
			$currentNetwork: readonlyType(stores.$currentNetwork),
			$currentClient: stores.$currentClient
		}
	};
}

//#endregion
export { createDAppKit, getWalletUniqueIdentifier };
//# sourceMappingURL=index.mjs.map