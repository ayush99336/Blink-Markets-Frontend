{"version":3,"file":"index.mjs","names":["wallet","getWalletForHandle","getOrCreateUiWalletForStandardWallet","getWalletForHandle","getOrCreateUiWalletAccountForStandardWalletAccount","account","getWalletAccountForUiWalletAccount","getWalletAccountForUiWalletAccount","getWalletAccountForUiWalletAccount","transaction","#chainConfig","#account","#keypair","#connect","#on","#signPersonalMessage","#signTransaction","#signAndExecuteTransaction"],"sources":["../src/utils/errors.ts","../src/utils/networks.ts","../src/utils/wallets.ts","../src/core/store.ts","../src/core/initializers/registered-wallets.ts","../src/core/actions/connect-wallet.ts","../src/core/initializers/autoconnect-wallet.ts","../src/utils/storage.ts","../src/core/initializers/sync-state-to-storage.ts","../src/core/initializers/manage-connection.ts","../src/core/actions/switch-network.ts","../src/core/actions/disconnect-wallet.ts","../src/core/actions/switch-account.ts","../src/core/actions/sign-personal-message.ts","../src/utils/transaction-result.ts","../src/core/actions/sign-and-execute-transaction.ts","../src/core/actions/sign-transaction.ts","../src/wallets/slush-web.ts","../src/wallets/index.ts","../src/wallets/unsafe-burner.ts","../src/core/index.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nexport class DAppKitError extends Error {}\n\n/**\n * Thown when someone attempts to perform an action that requires an active wallet connection.\n */\nexport class WalletNotConnectedError extends DAppKitError {}\n\n/**\n * Thown when an account tries to invoke a feature on a chain that doesn't support it.\n */\nexport class ChainNotSupportedError extends DAppKitError {}\n\n/**\n * Thown when an account tries to invoke a feature that it doesn't support.\n */\nexport class FeatureNotSupportedError extends DAppKitError {}\n\n/**\n * Thown when a wallet is connected but no accounts are authorized.\n */\nexport class WalletNoAccountsConnectedError extends DAppKitError {}\n\n/**\n * Thown when an account can't be found for a specific wallet.\n */\nexport class WalletAccountNotFoundError extends DAppKitError {}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { SuiClientTypes } from '@mysten/sui/client';\nimport type { IdentifierString } from '@mysten/wallet-standard';\nimport { DAppKitError } from './errors.js';\nimport type { DAppKitCompatibleClient } from '../core/types.js';\n\nexport type Networks = SuiClientTypes.Network[];\n\nexport function getChain(network: SuiClientTypes.Network): IdentifierString {\n\treturn `sui:${network}`;\n}\n\nexport function createNetworkConfig<\n\tTNetworks extends Networks,\n\tClient extends DAppKitCompatibleClient,\n>(networks: TNetworks, createClient: (network: TNetworks[number]) => Client) {\n\tif (networks.length === 0) {\n\t\tthrow new DAppKitError('You must specify at least one Sui network for your application.');\n\t}\n\n\tconst networkConfig = new Map<TNetworks[number], Client>();\n\tfunction getClient<T extends TNetworks[number]>(network: T | TNetworks[number]) {\n\t\tif (networkConfig.has(network)) {\n\t\t\treturn networkConfig.get(network)!;\n\t\t}\n\n\t\tconst client = createClient(network);\n\t\tnetworkConfig.set(network, client);\n\t\treturn client;\n\t}\n\n\treturn { networkConfig: Object.freeze(networkConfig), getClient };\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n\tStandardConnect,\n\tStandardEvents,\n\tSuiSignTransaction,\n\tSuiSignTransactionBlock,\n\tWALLET_STANDARD_ERROR__FEATURES__WALLET_ACCOUNT_CHAIN_UNSUPPORTED,\n\tWalletStandardError,\n} from '@mysten/wallet-standard';\nimport type { UiWallet, UiWalletAccount, UiWalletHandle } from '@wallet-standard/ui';\nimport { getWalletAccountFeature, uiWalletAccountBelongsToUiWallet } from '@wallet-standard/ui';\nimport { getWalletForHandle_DO_NOT_USE_OR_YOU_WILL_BE_FIRED as getWalletForHandle } from '@wallet-standard/ui-registry';\nimport { ChainNotSupportedError, DAppKitError, FeatureNotSupportedError } from './errors.js';\n\nexport const requiredWalletFeatures = [StandardConnect, StandardEvents] as const;\n\nexport const signingFeatures = [SuiSignTransaction, SuiSignTransactionBlock] as const;\n\nexport function getAssociatedWalletOrThrow(account: UiWalletAccount, wallets: UiWallet[]) {\n\tconst wallet = wallets.find((wallet) => uiWalletAccountBelongsToUiWallet(account, wallet));\n\tif (!wallet) {\n\t\tthrow new DAppKitError(`Wallet not found for account ${account.address}.`);\n\t}\n\treturn wallet;\n}\n\nexport function getWalletUniqueIdentifier(walletHandle: UiWalletHandle) {\n\tconst underlyingWallet = getWalletForHandle(walletHandle);\n\treturn underlyingWallet.id ?? underlyingWallet.name;\n}\n\nexport function getAccountFeature<TAccount extends UiWalletAccount>({\n\taccount,\n\tfeatureName,\n\tchain,\n}: {\n\taccount: TAccount;\n\tfeatureName: TAccount['features'][number];\n\tchain: TAccount['chains'][number];\n}) {\n\tif (!account.chains.includes(chain)) {\n\t\tconst cause = new WalletStandardError(\n\t\t\tWALLET_STANDARD_ERROR__FEATURES__WALLET_ACCOUNT_CHAIN_UNSUPPORTED,\n\t\t\t{\n\t\t\t\tchain,\n\t\t\t\tfeatureName,\n\t\t\t\tsupportedChains: [...account.chains],\n\t\t\t\tsupportedFeatures: [...account.features],\n\t\t\t\taddress: account.address,\n\t\t\t},\n\t\t);\n\n\t\tthrow new ChainNotSupportedError(\n\t\t\t`The account ${cause.context.address} does not support the chain \"${cause.context.chain}\".`,\n\t\t\t{ cause },\n\t\t);\n\t}\n\n\ttry {\n\t\treturn getWalletAccountFeature(account, featureName);\n\t} catch (error) {\n\t\tthrow new FeatureNotSupportedError(\n\t\t\t`The account ${account.address} does not support the feature \"${featureName}\".`,\n\t\t\t{ cause: error },\n\t\t);\n\t}\n}\n\nexport function tryGetAccountFeature<TAccount extends UiWalletAccount>(\n\t...args: Parameters<typeof getAccountFeature<TAccount>>\n) {\n\ttry {\n\t\treturn getAccountFeature(...args);\n\t} catch (error) {\n\t\tif (error instanceof FeatureNotSupportedError) {\n\t\t\treturn null;\n\t\t}\n\t\tthrow error;\n\t}\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { UiWallet, UiWalletAccount } from '@wallet-standard/ui';\nimport type { StoreValue } from 'nanostores';\nimport { atom, computed, map } from 'nanostores';\nimport { getChain } from '../utils/networks.js';\nimport type { Networks } from '../utils/networks.js';\nimport {\n\tgetAssociatedWalletOrThrow,\n\trequiredWalletFeatures,\n\tsigningFeatures,\n} from '../utils/wallets.js';\nimport type { DAppKitCompatibleClient } from './types.js';\n\ntype InternalWalletConnection =\n\t| {\n\t\t\tstatus: 'disconnected' | 'connecting';\n\t\t\tcurrentAccount: null;\n\t  }\n\t| {\n\t\t\tstatus: 'reconnecting' | 'connected';\n\t\t\tcurrentAccount: UiWalletAccount;\n\t\t\tsupportedIntents: string[];\n\t  };\n\nexport type DAppKitStores<\n\tTNetworks extends Networks = Networks,\n\tClient extends DAppKitCompatibleClient = DAppKitCompatibleClient,\n> = ReturnType<typeof createStores<TNetworks, Client>>;\n\nexport type WalletConnection = StoreValue<DAppKitStores['$connection']>;\n\nexport function createStores<\n\tTNetworks extends Networks = [],\n\tClient extends DAppKitCompatibleClient = DAppKitCompatibleClient,\n>({\n\tdefaultNetwork,\n\tgetClient,\n}: {\n\tdefaultNetwork: TNetworks[number];\n\tgetClient: (network: TNetworks[number]) => Client;\n}) {\n\tconst $baseConnection = map<InternalWalletConnection>({\n\t\tstatus: 'disconnected',\n\t\tcurrentAccount: null,\n\t});\n\n\tconst $currentNetwork = atom<TNetworks[number]>(defaultNetwork);\n\tconst $registeredWallets = atom<UiWallet[]>([]);\n\n\tconst $compatibleWallets = computed(\n\t\t[$registeredWallets, $currentNetwork],\n\t\t(wallets, currentNetwork) => {\n\t\t\treturn wallets.filter((wallet) => {\n\t\t\t\tconst areChainsCompatible = wallet.chains.some(\n\t\t\t\t\t(chain) => getChain(currentNetwork) === chain,\n\t\t\t\t);\n\n\t\t\t\tconst hasRequiredFeatures = requiredWalletFeatures.every((featureName) =>\n\t\t\t\t\twallet.features.includes(featureName),\n\t\t\t\t);\n\n\t\t\t\tconst canSignTransactions = signingFeatures.some((featureName) =>\n\t\t\t\t\twallet.features.includes(featureName),\n\t\t\t\t);\n\n\t\t\t\treturn areChainsCompatible && hasRequiredFeatures && canSignTransactions;\n\t\t\t});\n\t\t},\n\t);\n\n\treturn {\n\t\t$currentNetwork,\n\t\t$registeredWallets,\n\t\t$compatibleWallets,\n\t\t$baseConnection,\n\t\t$currentClient: computed($currentNetwork, getClient),\n\t\t$connection: computed([$baseConnection, $compatibleWallets], (connection, wallets) => {\n\t\t\tswitch (connection.status) {\n\t\t\t\tcase 'connected':\n\t\t\t\t\treturn {\n\t\t\t\t\t\twallet: getAssociatedWalletOrThrow(connection.currentAccount, wallets),\n\t\t\t\t\t\taccount: connection.currentAccount,\n\t\t\t\t\t\tstatus: connection.status,\n\t\t\t\t\t\tsupportedIntents: connection.supportedIntents,\n\t\t\t\t\t\tisConnected: true,\n\t\t\t\t\t\tisConnecting: false,\n\t\t\t\t\t\tisReconnecting: false,\n\t\t\t\t\t\tisDisconnected: false,\n\t\t\t\t\t} as const;\n\t\t\t\tcase 'connecting':\n\t\t\t\t\treturn {\n\t\t\t\t\t\twallet: null,\n\t\t\t\t\t\taccount: connection.currentAccount,\n\t\t\t\t\t\tstatus: connection.status,\n\t\t\t\t\t\tsupportedIntents: [],\n\t\t\t\t\t\tisConnected: false,\n\t\t\t\t\t\tisConnecting: true,\n\t\t\t\t\t\tisReconnecting: false,\n\t\t\t\t\t\tisDisconnected: false,\n\t\t\t\t\t} as const;\n\t\t\t\tcase 'reconnecting':\n\t\t\t\t\treturn {\n\t\t\t\t\t\twallet: getAssociatedWalletOrThrow(connection.currentAccount, wallets),\n\t\t\t\t\t\taccount: connection.currentAccount,\n\t\t\t\t\t\tstatus: connection.status,\n\t\t\t\t\t\tsupportedIntents: connection.supportedIntents,\n\t\t\t\t\t\tisConnected: false,\n\t\t\t\t\t\tisConnecting: false,\n\t\t\t\t\t\tisReconnecting: true,\n\t\t\t\t\t\tisDisconnected: false,\n\t\t\t\t\t} as const;\n\t\t\t\tcase 'disconnected':\n\t\t\t\t\treturn {\n\t\t\t\t\t\twallet: null,\n\t\t\t\t\t\taccount: connection.currentAccount,\n\t\t\t\t\t\tstatus: connection.status,\n\t\t\t\t\t\tsupportedIntents: [],\n\t\t\t\t\t\tisConnected: false,\n\t\t\t\t\t\tisConnecting: false,\n\t\t\t\t\t\tisReconnecting: false,\n\t\t\t\t\t\tisDisconnected: true,\n\t\t\t\t\t} as const;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Encountered unknown connection status: ${connection}`);\n\t\t\t}\n\t\t}),\n\t};\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { getWallets, StandardEvents } from '@mysten/wallet-standard';\nimport { onMount } from 'nanostores';\nimport type { DAppKitStores } from '../store.js';\n\nimport { getOrCreateUiWalletForStandardWallet_DO_NOT_USE_OR_YOU_WILL_BE_FIRED as getOrCreateUiWalletForStandardWallet } from '@wallet-standard/ui-registry';\nimport type { StandardEventsFeature, Wallet, WalletWithFeatures } from '@mysten/wallet-standard';\n\n/**\n * Handles updating the store in response to wallets being added, removed, and their properties changing.\n */\nexport function syncRegisteredWallets({ $registeredWallets }: DAppKitStores) {\n\tonMount($registeredWallets, () => {\n\t\tconst walletsApi = getWallets();\n\t\tconst unsubscribeCallbacksByWallet = new Map<Wallet, () => void>();\n\n\t\tconst onWalletsChanged = () => {\n\t\t\tconst wallets = walletsApi.get();\n\t\t\t$registeredWallets.set(wallets.map(getOrCreateUiWalletForStandardWallet));\n\t\t};\n\n\t\tconst subscribeToWalletEvents = (wallet: WalletWithFeatures<StandardEventsFeature>) => {\n\t\t\tconst unsubscribeFromChange = wallet.features[StandardEvents].on('change', () => {\n\t\t\t\tonWalletsChanged();\n\t\t\t});\n\n\t\t\t// NOTE: The underlying wallet entities returned from the Wallet Standard are\n\t\t\t// referentially equal even when the properties of a wallet change. Thus, it is\n\t\t\t// safe to use the wallet object itself as the key for the unsubscribe mapping.\n\t\t\tunsubscribeCallbacksByWallet.set(wallet, unsubscribeFromChange);\n\t\t};\n\n\t\tconst unsubscribeFromRegister = walletsApi.on('register', (...addedWallets) => {\n\t\t\taddedWallets.filter(hasStandardEvents).forEach(subscribeToWalletEvents);\n\t\t\tonWalletsChanged();\n\t\t});\n\n\t\tconst unsubscribeFromUnregister = walletsApi.on('unregister', (...removedWallets) => {\n\t\t\tremovedWallets.filter(hasStandardEvents).forEach((wallet) => {\n\t\t\t\tconst unsubscribeFromChange = unsubscribeCallbacksByWallet.get(wallet);\n\t\t\t\tif (unsubscribeFromChange) {\n\t\t\t\t\tunsubscribeCallbacksByWallet.delete(wallet);\n\t\t\t\t\tunsubscribeFromChange();\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tonWalletsChanged();\n\t\t});\n\n\t\tconst wallets = walletsApi.get();\n\t\twallets.filter(hasStandardEvents).forEach(subscribeToWalletEvents);\n\t\tonWalletsChanged();\n\n\t\treturn () => {\n\t\t\tunsubscribeFromRegister();\n\t\t\tunsubscribeFromUnregister();\n\n\t\t\tunsubscribeCallbacksByWallet.forEach((unsubscribe) => unsubscribe());\n\t\t\tunsubscribeCallbacksByWallet.clear();\n\t\t};\n\t});\n}\n\nfunction hasStandardEvents(wallet: Wallet): wallet is WalletWithFeatures<StandardEventsFeature> {\n\treturn StandardEvents in wallet.features;\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { DAppKitStores } from '../store.js';\nimport { task } from 'nanostores';\nimport type { UiWallet, UiWalletAccount } from '@wallet-standard/ui';\nimport type { StandardConnectInput, SuiWalletFeatures } from '@mysten/wallet-standard';\nimport type { StandardConnectFeature } from '@mysten/wallet-standard';\nimport { StandardConnect } from '@mysten/wallet-standard';\nimport { getWalletFeature, uiWalletAccountBelongsToUiWallet } from '@wallet-standard/ui';\nimport {\n\tgetOrCreateUiWalletAccountForStandardWalletAccount_DO_NOT_USE_OR_YOU_WILL_BE_FIRED as getOrCreateUiWalletAccountForStandardWalletAccount,\n\tgetWalletForHandle_DO_NOT_USE_OR_YOU_WILL_BE_FIRED as getWalletForHandle,\n} from '@wallet-standard/ui-registry';\nimport { WalletAccountNotFoundError, WalletNoAccountsConnectedError } from '../../utils/errors.js';\nimport { getChain } from '../../utils/networks.js';\nimport type { Networks } from '../../utils/networks.js';\n\nexport type ConnectWalletArgs = {\n\t/** The wallet to connect to. */\n\twallet: UiWallet;\n\n\t/**\n\t * An optional account to set as the selected account.\n\t * @default The first authorized account.\n\t */\n\taccount?: UiWalletAccount;\n} & Omit<StandardConnectInput, 'silent'>;\n\nexport function connectWalletCreator(\n\t{ $baseConnection }: DAppKitStores,\n\tsupportedNetworks: Networks,\n) {\n\t/**\n\t * Prompts the specified wallet to connect and authorize new accounts for the current domain.\n\t */\n\treturn async function connectWallet({\n\t\twallet,\n\t\taccount,\n\t\t...standardConnectArgs\n\t}: ConnectWalletArgs) {\n\t\treturn await task(async () => {\n\t\t\tconst connection = $baseConnection.get();\n\t\t\tconst isAlreadyConnected = connection.status === 'connected';\n\n\t\t\ttry {\n\t\t\t\t$baseConnection.setKey('status', isAlreadyConnected ? 'reconnecting' : 'connecting');\n\n\t\t\t\tconst { accounts: suiAccounts, supportedIntents } = await internalConnectWallet(\n\t\t\t\t\twallet,\n\t\t\t\t\tsupportedNetworks,\n\t\t\t\t\tstandardConnectArgs,\n\t\t\t\t);\n\n\t\t\t\tif (!isAlreadyConnected && suiAccounts.length === 0) {\n\t\t\t\t\tthrow new WalletNoAccountsConnectedError('No accounts were authorized.');\n\t\t\t\t}\n\n\t\t\t\tif (account && !uiWalletAccountBelongsToUiWallet(account, wallet)) {\n\t\t\t\t\tthrow new WalletAccountNotFoundError(\n\t\t\t\t\t\t`No account with address ${account.address} is authorized for ${wallet.name}.`,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\t$baseConnection.set({\n\t\t\t\t\tstatus: 'connected',\n\t\t\t\t\tcurrentAccount: account ?? suiAccounts[0],\n\t\t\t\t\tsupportedIntents: supportedIntents ?? [],\n\t\t\t\t});\n\n\t\t\t\treturn { accounts: suiAccounts };\n\t\t\t} catch (error) {\n\t\t\t\t$baseConnection.setKey('status', isAlreadyConnected ? 'connected' : 'disconnected');\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t});\n\t};\n}\n\nexport async function internalConnectWallet(\n\twallet: UiWallet,\n\tsupportedNetworks: Networks,\n\targs: StandardConnectInput,\n) {\n\tconst { connect } = getWalletFeature(\n\t\twallet,\n\t\tStandardConnect,\n\t) as StandardConnectFeature[typeof StandardConnect];\n\n\tconst result = await connect(args);\n\n\tconst underlyingWallet = getWalletForHandle(wallet);\n\tconst supportedChains = supportedNetworks.map(getChain);\n\tconst supportedIntents =\n\t\tresult.supportedIntents ?? (await getSupportedIntentsFromFeature(wallet));\n\tconst accounts = result.accounts\n\t\t.filter((account) => account.chains.some((chain) => supportedChains.includes(chain)))\n\t\t.map(getOrCreateUiWalletAccountForStandardWalletAccount.bind(null, underlyingWallet));\n\n\treturn {\n\t\taccounts,\n\t\tsupportedIntents,\n\t};\n}\n\nexport async function getSupportedIntentsFromFeature(wallet: UiWallet) {\n\tif (!wallet.features.includes('sui:getCapabilities')) {\n\t\treturn [];\n\t}\n\n\tconst getCapabilitiesFeature = getWalletFeature(\n\t\twallet,\n\t\t'sui:getCapabilities',\n\t) as SuiWalletFeatures['sui:getCapabilities'];\n\n\treturn (await getCapabilitiesFeature?.getCapabilities())?.supportedIntents ?? [];\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { onMount, task } from 'nanostores';\nimport type { DAppKitStores } from '../store.js';\nimport type { StateStorage } from '../../utils/storage.js';\nimport type { UiWallet } from '@wallet-standard/ui';\nimport { getWalletUniqueIdentifier } from '../../utils/wallets.js';\n\nimport {\n\tgetSupportedIntentsFromFeature,\n\tinternalConnectWallet,\n} from '../actions/connect-wallet.js';\nimport type { Networks } from '../../utils/networks.js';\n\n/**\n * Attempts to connect to a previously authorized wallet account on mount and when new wallets are registered.\n */\nexport function autoConnectWallet({\n\tnetworks,\n\tstores: { $baseConnection, $compatibleWallets },\n\tstorage,\n\tstorageKey,\n}: {\n\tnetworks: Networks;\n\tstores: DAppKitStores;\n\tstorage: StateStorage;\n\tstorageKey: string;\n}) {\n\tonMount($compatibleWallets, () => {\n\t\treturn $compatibleWallets.listen(\n\t\t\tasync (wallets, oldWallets: readonly UiWallet[] | undefined) => {\n\t\t\t\tif (oldWallets && oldWallets.length > wallets.length) return;\n\n\t\t\t\tconst connection = $baseConnection.get();\n\t\t\t\tif (connection.status !== 'disconnected') return;\n\n\t\t\t\tconst savedWalletAccount = await task(() => {\n\t\t\t\t\treturn getSavedWalletAccount({\n\t\t\t\t\t\tnetworks,\n\t\t\t\t\t\tstorage,\n\t\t\t\t\t\tstorageKey,\n\t\t\t\t\t\twallets,\n\t\t\t\t\t});\n\t\t\t\t});\n\n\t\t\t\tif (savedWalletAccount) {\n\t\t\t\t\t$baseConnection.set({\n\t\t\t\t\t\tstatus: 'connected',\n\t\t\t\t\t\tcurrentAccount: savedWalletAccount.account,\n\t\t\t\t\t\tsupportedIntents: savedWalletAccount.supportedIntents,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t},\n\t\t);\n\t});\n}\n\nasync function getSavedWalletAccount({\n\tnetworks,\n\tstorage,\n\tstorageKey,\n\twallets,\n}: {\n\tnetworks: Networks;\n\tstorage: StateStorage;\n\tstorageKey: string;\n\twallets: readonly UiWallet[];\n}) {\n\tconst savedWalletIdAndAddress = await storage.getItem(storageKey);\n\tif (!savedWalletIdAndAddress) {\n\t\treturn null;\n\t}\n\n\tconst [savedWalletId, savedAccountAddress, savedIntents] = savedWalletIdAndAddress.split(':');\n\tif (!savedWalletId || !savedAccountAddress) {\n\t\treturn null;\n\t}\n\n\tconst targetWallet = wallets.find(\n\t\t(wallet) => getWalletUniqueIdentifier(wallet) === savedWalletId,\n\t);\n\n\tif (!targetWallet) {\n\t\treturn null;\n\t}\n\n\tconst existingAccount = targetWallet.accounts.find(\n\t\t(account) => account.address === savedAccountAddress,\n\t);\n\n\tif (existingAccount) {\n\t\tconst supportedIntents = savedIntents ? savedIntents.split(',') : null;\n\n\t\treturn {\n\t\t\taccount: existingAccount,\n\t\t\tsupportedIntents: supportedIntents ?? (await getSupportedIntentsFromFeature(targetWallet)),\n\t\t};\n\t}\n\n\t// For wallets that don't pre-populate the accounts array on page load,\n\t// we need to silently request authorization and get the account directly.\n\tconst { accounts: alreadyAuthorizedAccounts, supportedIntents } = await internalConnectWallet(\n\t\ttargetWallet,\n\t\tnetworks,\n\t\t{\n\t\t\tsilent: true,\n\t\t},\n\t);\n\n\tconst account = alreadyAuthorizedAccounts.find(\n\t\t(account) => account.address === savedAccountAddress,\n\t);\n\n\treturn account ? { account, supportedIntents } : null;\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nexport type StateStorage = {\n\tgetItem: (name: string) => string | null | Promise<string | null>;\n\tsetItem: (name: string, value: string) => unknown | Promise<unknown>;\n\tremoveItem: (name: string) => unknown | Promise<unknown>;\n};\n\nexport const DEFAULT_STORAGE_KEY = 'mysten-dapp-kit:selected-wallet-and-address';\n\nexport function getDefaultStorage() {\n\treturn isLocalStorageAvailable() ? localStorage : createInMemoryStorage();\n}\n\nexport function createInMemoryStorage(): StateStorage {\n\tconst store = new Map<string, string>();\n\treturn {\n\t\tgetItem(key: string) {\n\t\t\treturn store.get(key) ?? null;\n\t\t},\n\t\tsetItem(key: string, value: string) {\n\t\t\tstore.set(key, value);\n\t\t},\n\t\tremoveItem(key: string) {\n\t\t\tstore.delete(key);\n\t\t},\n\t};\n}\n\nfunction isLocalStorageAvailable() {\n\ttry {\n\t\tconst testKey = '__storage_test__';\n\t\tlocalStorage.setItem(testKey, 'test');\n\t\tlocalStorage.removeItem(testKey);\n\t\treturn true;\n\t} catch {\n\t\treturn false;\n\t}\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { onMount } from 'nanostores';\nimport type { DAppKitStores } from '../store.js';\nimport type { StateStorage } from '../../utils/storage.js';\nimport type { UiWalletAccount } from '@wallet-standard/ui';\nimport { getWalletUniqueIdentifier } from '../../utils/wallets.js';\n\n/**\n * Syncs the most recently connected wallet name and address to storage.\n */\nexport function syncStateToStorage({\n\tstores: { $connection },\n\tstorage,\n\tstorageKey,\n}: {\n\tstores: DAppKitStores;\n\tstorage: StateStorage;\n\tstorageKey: string;\n}) {\n\tonMount($connection, () => {\n\t\treturn $connection.listen((connection, oldConnection) => {\n\t\t\tif (!oldConnection || oldConnection.status === connection.status) return;\n\n\t\t\tif (connection.account) {\n\t\t\t\tstorage.setItem(\n\t\t\t\t\tstorageKey,\n\t\t\t\t\tgetSavedAccountStorageKey(connection.account, connection.supportedIntents),\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tstorage.removeItem(storageKey);\n\t\t\t}\n\t\t});\n\t});\n}\n\nexport function getSavedAccountStorageKey(\n\taccount: UiWalletAccount,\n\tsupportedIntents: string[],\n): string {\n\tconst walletIdentifier = getWalletUniqueIdentifier(account);\n\treturn `${walletIdentifier.replace(':', '_')}:${account.address}:${supportedIntents.join(',')}:`;\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { onMount } from 'nanostores';\nimport type { DAppKitStores } from '../store.js';\n\nimport type { UiWallet, UiWalletAccount } from '@wallet-standard/ui';\nimport { uiWalletAccountBelongsToUiWallet, uiWalletAccountsAreSame } from '@wallet-standard/ui';\n\n/**\n * Handles updating the connection state in response to wallets and their properties changing.\n */\nexport function manageWalletConnection({ $compatibleWallets, $baseConnection }: DAppKitStores) {\n\tonMount($compatibleWallets, () => {\n\t\treturn $compatibleWallets.listen(async (wallets) => {\n\t\t\tconst connection = $baseConnection.get();\n\t\t\tif (connection.status !== 'connected') return;\n\n\t\t\tconst resolvedAccount = resolveWalletAccount(connection.currentAccount, wallets);\n\t\t\tif (resolvedAccount) {\n\t\t\t\t// Update the current account in response to the account properties changing.\n\t\t\t\t// If the current account was deemed incompatible, we'll default to the\n\t\t\t\t// first account in the wallet:\n\t\t\t\t$baseConnection.setKey('currentAccount', resolvedAccount);\n\t\t\t} else {\n\t\t\t\t// Reset the connection if the underlying wallet was un-registered or deemed incompatible:\n\t\t\t\t$baseConnection.set({\n\t\t\t\t\tstatus: 'disconnected',\n\t\t\t\t\tcurrentAccount: null,\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t});\n}\n\nfunction resolveWalletAccount(currentAccount: UiWalletAccount, wallets: readonly UiWallet[]) {\n\tfor (const wallet of wallets) {\n\t\tfor (const walletAccount of wallet.accounts) {\n\t\t\tif (uiWalletAccountsAreSame(currentAccount, walletAccount)) {\n\t\t\t\treturn walletAccount;\n\t\t\t}\n\t\t}\n\n\t\tif (uiWalletAccountBelongsToUiWallet(currentAccount, wallet) && wallet.accounts[0]) {\n\t\t\treturn wallet.accounts[0];\n\t\t}\n\t}\n\n\treturn null;\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { DAppKitStores } from '../store.js';\nimport type { Networks } from '../../utils/networks.js';\n\nexport function switchNetworkCreator<TNetworks extends Networks>({\n\t$currentNetwork,\n}: DAppKitStores<TNetworks>) {\n\t/**\n\t * Switches the currently selected network to the specified network.\n\t */\n\treturn function switchNetwork<T extends TNetworks[number]>(network: T | TNetworks[number]) {\n\t\t$currentNetwork.set(network);\n\t};\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { StandardDisconnectFeature, StandardDisconnectMethod } from '@mysten/wallet-standard';\nimport { StandardDisconnect } from '@mysten/wallet-standard';\nimport type { DAppKitStores } from '../store.js';\nimport { task } from 'nanostores';\nimport { getWalletFeature } from '@wallet-standard/ui';\nimport { WalletNotConnectedError } from '../../utils/errors.js';\n\nexport type DisconnectWalletArgs = Parameters<StandardDisconnectMethod>;\n\nexport function disconnectWalletCreator({ $baseConnection, $connection }: DAppKitStores) {\n\t/**\n\t * Disconnects the current wallet from the application and prompts the current wallet\n\t * to deauthorize accounts from the current domain depending on the wallet's implemetation\n\t * of `standard:disconnect`.\n\t */\n\treturn async function disconnectWallet(...standardDisconnectArgs: DisconnectWalletArgs) {\n\t\treturn await task(async () => {\n\t\t\tconst { wallet } = $connection.get();\n\t\t\tif (!wallet) {\n\t\t\t\tthrow new WalletNotConnectedError('No wallet is connected.');\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tconst { disconnect } = getWalletFeature(\n\t\t\t\t\twallet,\n\t\t\t\t\tStandardDisconnect,\n\t\t\t\t) as StandardDisconnectFeature[typeof StandardDisconnect];\n\n\t\t\t\tawait disconnect(...standardDisconnectArgs);\n\t\t\t} catch (error) {\n\t\t\t\tconsole.warn('Failed to disconnect the current wallet from the application.', error);\n\t\t\t} finally {\n\t\t\t\t$baseConnection.set({\n\t\t\t\t\tstatus: 'disconnected',\n\t\t\t\t\tcurrentAccount: null,\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t};\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { DAppKitStores } from '../store.js';\nimport { uiWalletAccountBelongsToUiWallet } from '@wallet-standard/ui';\nimport type { UiWalletAccount } from '@wallet-standard/ui';\nimport { WalletNotConnectedError, WalletAccountNotFoundError } from '../../utils/errors.js';\n\nexport type SwitchAccountArgs = {\n\t/** The account to switch to. */\n\taccount: UiWalletAccount;\n};\n\nexport function switchAccountCreator({ $baseConnection, $connection }: DAppKitStores) {\n\t/**\n\t * Switches the currently selected account to the specified account.\n\t */\n\treturn function switchAccount({ account }: SwitchAccountArgs) {\n\t\tconst { wallet } = $connection.get();\n\t\tif (!wallet) {\n\t\t\tthrow new WalletNotConnectedError('No wallet is connected.');\n\t\t}\n\n\t\tif (!uiWalletAccountBelongsToUiWallet(account, wallet)) {\n\t\t\tthrow new WalletAccountNotFoundError(\n\t\t\t\t`No account with address ${account.address} is connected to ${wallet.name}.`,\n\t\t\t);\n\t\t}\n\n\t\t$baseConnection.setKey('currentAccount', account);\n\t};\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { DAppKitStores } from '../store.js';\nimport { SuiSignPersonalMessage } from '@mysten/wallet-standard';\nimport type {\n\tSuiSignPersonalMessageFeature,\n\tSuiSignPersonalMessageInput,\n} from '@mysten/wallet-standard';\nimport { getWalletAccountForUiWalletAccount_DO_NOT_USE_OR_YOU_WILL_BE_FIRED as getWalletAccountForUiWalletAccount } from '@wallet-standard/ui-registry';\nimport { WalletNotConnectedError } from '../../utils/errors.js';\nimport { getChain } from '../../utils/networks.js';\nimport { getAccountFeature } from '../../utils/wallets.js';\n\nexport type SignPersonalMessageArgs = Omit<SuiSignPersonalMessageInput, 'account' | 'chain'>;\n\nexport function signPersonalMessageCreator({ $connection, $currentNetwork }: DAppKitStores) {\n\t/**\n\t * Prompts the specified wallet account to sign a personal message.\n\t */\n\treturn async function signPersonalMessage({ ...standardArgs }: SignPersonalMessageArgs) {\n\t\tconst { account } = $connection.get();\n\t\tif (!account) {\n\t\t\tthrow new WalletNotConnectedError('No wallet is connected.');\n\t\t}\n\n\t\tconst currentNetwork = $currentNetwork.get();\n\t\tconst chain = getChain(currentNetwork);\n\n\t\tconst signPersonalMessageFeature = getAccountFeature({\n\t\t\taccount: account,\n\t\t\tchain,\n\t\t\tfeatureName: SuiSignPersonalMessage,\n\t\t}) as SuiSignPersonalMessageFeature[typeof SuiSignPersonalMessage];\n\n\t\treturn await signPersonalMessageFeature.signPersonalMessage({\n\t\t\t...standardArgs,\n\t\t\taccount: getWalletAccountForUiWalletAccount(account),\n\t\t\tchain,\n\t\t});\n\t};\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n\textractStatusFromEffectsBcs,\n\tparseTransactionBcs,\n\tparseTransactionEffectsBcs,\n\ttype SuiClientTypes,\n} from '@mysten/sui/client';\n\nexport type TransactionResultWithEffects = SuiClientTypes.TransactionResult<{\n\teffects: true;\n\ttransaction: true;\n\tbcs: true;\n}>;\n\nexport function buildTransactionResult(\n\tdigest: string,\n\tsignature: string,\n\ttransactionBytes: Uint8Array,\n\teffectsBytes: Uint8Array,\n): TransactionResultWithEffects {\n\tconst status = extractStatusFromEffectsBcs(effectsBytes);\n\n\tlet effects: SuiClientTypes.TransactionEffects | null = null;\n\ttry {\n\t\teffects = parseTransactionEffectsBcs(effectsBytes);\n\t} catch {\n\t\tconsole.warn(\n\t\t\t'Parsing transaction effects failed, you may need to update the SDK to pickup the latest bcs types',\n\t\t);\n\t}\n\n\tconst txResult: SuiClientTypes.Transaction<{ effects: true; transaction: true; bcs: true }> = {\n\t\tdigest,\n\t\tsignatures: [signature],\n\t\tepoch: null,\n\t\tstatus,\n\t\teffects: effects as SuiClientTypes.TransactionEffects,\n\t\ttransaction: parseTransactionBcs(transactionBytes),\n\t\tbalanceChanges: undefined,\n\t\tevents: undefined,\n\t\tobjectTypes: undefined,\n\t\tbcs: transactionBytes,\n\t};\n\n\treturn status.success\n\t\t? { $kind: 'Transaction', Transaction: txResult }\n\t\t: { $kind: 'FailedTransaction', FailedTransaction: txResult };\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { DAppKitStores } from '../store.js';\nimport {\n\tSuiSignAndExecuteTransaction,\n\tSuiSignAndExecuteTransactionBlock,\n} from '@mysten/wallet-standard';\nimport type {\n\tSuiSignAndExecuteTransactionBlockFeature,\n\tSuiSignAndExecuteTransactionFeature,\n\tSuiSignAndExecuteTransactionInput,\n} from '@mysten/wallet-standard';\nimport { getWalletAccountForUiWalletAccount_DO_NOT_USE_OR_YOU_WILL_BE_FIRED as getWalletAccountForUiWalletAccount } from '@wallet-standard/ui-registry';\nimport { FeatureNotSupportedError, WalletNotConnectedError } from '../../utils/errors.js';\nimport { getChain } from '../../utils/networks.js';\nimport { Transaction } from '@mysten/sui/transactions';\nimport { tryGetAccountFeature } from '../../utils/wallets.js';\nimport { bcs } from '@mysten/sui/bcs';\nimport { fromBase64 } from '@mysten/utils';\nimport {\n\tbuildTransactionResult,\n\ttype TransactionResultWithEffects,\n} from '../../utils/transaction-result.js';\n\nexport type SignAndExecuteTransactionArgs = {\n\ttransaction: Transaction | string;\n} & Omit<SuiSignAndExecuteTransactionInput, 'account' | 'chain' | 'transaction'>;\n\nexport type SignAndExecuteTransactionResult = TransactionResultWithEffects;\n\nexport function signAndExecuteTransactionCreator({ $connection, $currentClient }: DAppKitStores) {\n\t/**\n\t * Prompts the specified wallet account to sign and execute a transaction.\n\t */\n\treturn async function signAndExecuteTransaction({\n\t\ttransaction,\n\t\t...standardArgs\n\t}: SignAndExecuteTransactionArgs): Promise<SignAndExecuteTransactionResult> {\n\t\tconst { account, supportedIntents } = $connection.get();\n\t\tif (!account) {\n\t\t\tthrow new WalletNotConnectedError('No wallet is connected.');\n\t\t}\n\n\t\tconst underlyingAccount = getWalletAccountForUiWalletAccount(account);\n\t\tconst suiClient = $currentClient.get();\n\t\tconst chain = getChain(suiClient.network);\n\n\t\tconst transactionWrapper = {\n\t\t\ttoJSON: async () => {\n\t\t\t\tif (typeof transaction === 'string') {\n\t\t\t\t\treturn transaction;\n\t\t\t\t}\n\n\t\t\t\ttransaction.setSenderIfNotSet(account.address);\n\t\t\t\treturn await transaction.toJSON({ client: suiClient, supportedIntents });\n\t\t\t},\n\t\t};\n\n\t\tconst signAndExecuteTransactionFeature = tryGetAccountFeature({\n\t\t\taccount,\n\t\t\tchain,\n\t\t\tfeatureName: SuiSignAndExecuteTransaction,\n\t\t}) as SuiSignAndExecuteTransactionFeature[typeof SuiSignAndExecuteTransaction];\n\n\t\tif (signAndExecuteTransactionFeature) {\n\t\t\tconst result = await signAndExecuteTransactionFeature.signAndExecuteTransaction({\n\t\t\t\t...standardArgs,\n\t\t\t\taccount: underlyingAccount,\n\t\t\t\ttransaction: transactionWrapper,\n\t\t\t\tchain,\n\t\t\t});\n\n\t\t\tconst transactionBytes = fromBase64(result.bytes);\n\t\t\tconst effectsBytes = fromBase64(result.effects);\n\t\t\treturn buildTransactionResult(\n\t\t\t\tresult.digest,\n\t\t\t\tresult.signature,\n\t\t\t\ttransactionBytes,\n\t\t\t\teffectsBytes,\n\t\t\t);\n\t\t}\n\n\t\tconst signAndExecuteTransactionBlockFeature = tryGetAccountFeature({\n\t\t\taccount,\n\t\t\tchain,\n\t\t\tfeatureName: SuiSignAndExecuteTransactionBlock,\n\t\t}) as SuiSignAndExecuteTransactionBlockFeature[typeof SuiSignAndExecuteTransactionBlock];\n\n\t\tif (signAndExecuteTransactionBlockFeature) {\n\t\t\tconst transactionBlock = Transaction.from(await transactionWrapper.toJSON());\n\t\t\tconst { digest, rawEffects, rawTransaction } =\n\t\t\t\tawait signAndExecuteTransactionBlockFeature.signAndExecuteTransactionBlock({\n\t\t\t\t\taccount,\n\t\t\t\t\tchain,\n\t\t\t\t\ttransactionBlock,\n\t\t\t\t\toptions: {\n\t\t\t\t\t\tshowRawEffects: true,\n\t\t\t\t\t\tshowRawInput: true,\n\t\t\t\t\t},\n\t\t\t\t});\n\n\t\t\tconst [\n\t\t\t\t{\n\t\t\t\t\ttxSignatures: [signature],\n\t\t\t\t\tintentMessage: { value: bcsTransaction },\n\t\t\t\t},\n\t\t\t] = bcs.SenderSignedData.parse(fromBase64(rawTransaction!));\n\n\t\t\tconst transactionBytes = bcs.TransactionData.serialize(bcsTransaction).toBytes();\n\t\t\tconst effectsBytes = new Uint8Array(rawEffects!);\n\t\t\treturn buildTransactionResult(digest, signature, transactionBytes, effectsBytes);\n\t\t}\n\n\t\tthrow new FeatureNotSupportedError(\n\t\t\t`The account ${account.address} does not support signing and executing transactions.`,\n\t\t);\n\t};\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { DAppKitStores } from '../store.js';\nimport { SuiSignTransaction, SuiSignTransactionBlock } from '@mysten/wallet-standard';\nimport type {\n\tSuiSignTransactionBlockFeature,\n\tSuiSignTransactionFeature,\n\tSuiSignTransactionInput,\n} from '@mysten/wallet-standard';\nimport { getWalletAccountForUiWalletAccount_DO_NOT_USE_OR_YOU_WILL_BE_FIRED as getWalletAccountForUiWalletAccount } from '@wallet-standard/ui-registry';\nimport { FeatureNotSupportedError, WalletNotConnectedError } from '../../utils/errors.js';\nimport { getChain } from '../../utils/networks.js';\nimport { Transaction } from '@mysten/sui/transactions';\nimport { tryGetAccountFeature } from '../../utils/wallets.js';\n\nexport type SignTransactionArgs = {\n\ttransaction: Transaction | string;\n} & Omit<SuiSignTransactionInput, 'account' | 'chain' | 'transaction'>;\n\nexport function signTransactionCreator({ $connection, $currentClient }: DAppKitStores) {\n\t/**\n\t * Prompts the specified wallet account to sign a transaction.\n\t */\n\treturn async function signTransaction({ transaction, ...standardArgs }: SignTransactionArgs) {\n\t\tconst { account, supportedIntents } = $connection.get();\n\t\tif (!account) {\n\t\t\tthrow new WalletNotConnectedError('No wallet is connected.');\n\t\t}\n\n\t\tconst underlyingAccount = getWalletAccountForUiWalletAccount(account);\n\t\tconst suiClient = $currentClient.get();\n\t\tconst chain = getChain(suiClient.network);\n\n\t\tconst transactionWrapper = {\n\t\t\ttoJSON: async () => {\n\t\t\t\tif (typeof transaction === 'string') {\n\t\t\t\t\treturn transaction;\n\t\t\t\t}\n\n\t\t\t\ttransaction.setSenderIfNotSet(account.address);\n\t\t\t\treturn await transaction.toJSON({ client: suiClient, supportedIntents });\n\t\t\t},\n\t\t};\n\n\t\tconst signTransactionFeature = tryGetAccountFeature({\n\t\t\taccount,\n\t\t\tchain,\n\t\t\tfeatureName: SuiSignTransaction,\n\t\t}) as SuiSignTransactionFeature[typeof SuiSignTransaction];\n\n\t\tif (signTransactionFeature) {\n\t\t\treturn await signTransactionFeature.signTransaction({\n\t\t\t\t...standardArgs,\n\t\t\t\ttransaction: transactionWrapper,\n\t\t\t\taccount: underlyingAccount,\n\t\t\t\tchain,\n\t\t\t});\n\t\t}\n\n\t\tconst signTransactionBlockFeature = tryGetAccountFeature({\n\t\t\taccount,\n\t\t\tchain,\n\t\t\tfeatureName: SuiSignTransactionBlock,\n\t\t}) as SuiSignTransactionBlockFeature[typeof SuiSignTransactionBlock];\n\n\t\tif (signTransactionBlockFeature) {\n\t\t\tconst transaction = Transaction.from(await transactionWrapper.toJSON());\n\t\t\tconst { transactionBlockBytes, signature } =\n\t\t\t\tawait signTransactionBlockFeature.signTransactionBlock({\n\t\t\t\t\ttransactionBlock: transaction,\n\t\t\t\t\taccount: underlyingAccount,\n\t\t\t\t\tchain,\n\t\t\t\t});\n\n\t\t\treturn { bytes: transactionBlockBytes, signature };\n\t\t}\n\n\t\tthrow new FeatureNotSupportedError(\n\t\t\t`The account ${account.address} does not support signing transactions.`,\n\t\t);\n\t};\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { registerSlushWallet } from '@mysten/slush-wallet';\nimport type { SlushWalletConfig } from '../core/types.js';\nimport type { WalletInitializer } from './index.js';\n\nexport function slushWebWalletInitializer(config?: SlushWalletConfig): WalletInitializer {\n\treturn {\n\t\tid: 'slush-web-wallet-initializer',\n\t\tasync initialize() {\n\t\t\tconst appName = config?.appName || getDefaultAppName();\n\t\t\tconst result = await registerSlushWallet(appName, {\n\t\t\t\torigin: config?.origin,\n\t\t\t\tmetadataApiUrl: config?.metadataApiUrl,\n\t\t\t});\n\n\t\t\tif (!result) throw new Error('Registration un-successful.');\n\t\t\treturn { unregister: result.unregister };\n\t\t},\n\t};\n}\n\nfunction getDefaultAppName() {\n\tconst appNameElement = document.querySelector<HTMLMetaElement>(`meta[name=\"application-name\"]`);\n\treturn appNameElement?.content || document.title;\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { Networks } from '../utils/networks.js';\nimport type { DAppKitCompatibleClient } from '../core/types.js';\n\nexport type UnregisterCallback = () => void;\n\ntype InitializeArgs = {\n\tnetworks: Networks;\n\tgetClient: (network?: Networks[number]) => DAppKitCompatibleClient;\n};\n\ntype InitializeResult = {\n\tunregister: () => void;\n};\n\nexport type WalletInitializer = {\n\tid: string;\n\tinitialize(input: InitializeArgs): InitializeResult | Promise<InitializeResult>;\n};\n\n// The wallet standard registers wallets globally and uses object references\n// to keep prevent duplicate wallets from being registered. For applications\n// that register interfaces with hot module replacement enabled locally, this\n// doesn't quite work as expected as the original object reference gets lost.\n//\n// To work around this and other complexities around when nanostore stores mount\n// and unmount, we can simply track initializers at the module level to ensure\n// that wallets get re-registered and de-duped properly when there are multiple\n// dApp Kit instances, across HMR reloads, etc.\nconst initializerMap = new Map<string, UnregisterCallback>();\n\nexport async function registerAdditionalWallets(\n\tinitializers: WalletInitializer[],\n\targs: InitializeArgs,\n) {\n\tinitializerMap.forEach((unregister) => unregister());\n\tinitializerMap.clear();\n\n\tconst uniqueInitializers = [...new Map(initializers.map((init) => [init.id, init])).values()];\n\tconst initializePromises = uniqueInitializers.map(async (initializer) => {\n\t\tconst result = await initializer.initialize(args);\n\t\treturn { initializer, result };\n\t});\n\n\tconst initializerResults = await Promise.allSettled(initializePromises);\n\tfor (const settledResult of initializerResults) {\n\t\tif (settledResult.status === 'fulfilled') {\n\t\t\tconst { initializer, result } = settledResult.value;\n\t\t\tinitializerMap.set(initializer.id, result.unregister);\n\t\t} else {\n\t\t\tconsole.warn(`Skipping wallet initializer: \"${settledResult.reason}\".`);\n\t\t}\n\t}\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Ed25519Keypair } from '@mysten/sui/keypairs/ed25519';\nimport { Transaction } from '@mysten/sui/transactions';\nimport type {\n\tIdentifierArray,\n\tIdentifierString,\n\tStandardConnectFeature,\n\tStandardConnectMethod,\n\tStandardEventsFeature,\n\tStandardEventsOnMethod,\n\tSuiFeatures,\n\tSuiSignAndExecuteTransactionMethod,\n\tSuiSignPersonalMessageMethod,\n\tSuiSignTransactionMethod,\n} from '@mysten/wallet-standard';\nimport {\n\tgetWallets,\n\tReadonlyWalletAccount,\n\tStandardConnect,\n\tStandardEvents,\n\tSuiSignAndExecuteTransaction,\n\tSuiSignPersonalMessage,\n\tSuiSignTransaction,\n} from '@mysten/wallet-standard';\nimport type { Wallet } from '@mysten/wallet-standard';\nimport { toBase64 } from '@mysten/utils';\nimport type { ClientWithCoreApi } from '@mysten/sui/client';\nimport type { WalletInitializer } from './index.js';\nimport { getChain } from '../utils/networks.js';\n\nexport function unsafeBurnerWalletInitializer(): WalletInitializer {\n\treturn {\n\t\tid: 'unsafe-burner-initalizer',\n\t\tasync initialize({ networks, getClient }) {\n\t\t\tconst wallet = new UnsafeBurnerWallet({ clients: networks.map(getClient) });\n\t\t\tconst unregister = getWallets().register(wallet);\n\t\t\treturn { unregister };\n\t\t},\n\t};\n}\n\nexport class UnsafeBurnerWallet implements Wallet {\n\t#chainConfig: Record<IdentifierString, ClientWithCoreApi>;\n\t#keypair = new Ed25519Keypair();\n\t#account: ReadonlyWalletAccount;\n\n\tconstructor({ clients }: { clients: ClientWithCoreApi[] }) {\n\t\tthis.#chainConfig = clients.reduce<Record<IdentifierString, ClientWithCoreApi>>(\n\t\t\t(accumulator, client) => {\n\t\t\t\tconst chain = getChain(client.network);\n\t\t\t\taccumulator[chain] = client;\n\t\t\t\treturn accumulator;\n\t\t\t},\n\t\t\t{},\n\t\t);\n\n\t\tthis.#account = new ReadonlyWalletAccount({\n\t\t\taddress: this.#keypair.getPublicKey().toSuiAddress(),\n\t\t\tpublicKey: this.#keypair.getPublicKey().toSuiBytes(),\n\t\t\tchains: this.chains,\n\t\t\tfeatures: [SuiSignTransaction, SuiSignAndExecuteTransaction, SuiSignPersonalMessage],\n\t\t});\n\n\t\tconsole.warn(\n\t\t\t'Your application is currently using the unsafe burner wallet. Make sure that this wallet is disabled in production.',\n\t\t);\n\t}\n\n\tget version() {\n\t\treturn '1.0.0' as const;\n\t}\n\n\tget name() {\n\t\treturn 'Unsafe Burner Wallet' as const;\n\t}\n\n\tget icon() {\n\t\treturn 'data:image/png;base64,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' as const;\n\t}\n\n\tget chains() {\n\t\treturn Object.keys(this.#chainConfig) as IdentifierArray;\n\t}\n\n\tget accounts() {\n\t\treturn [this.#account];\n\t}\n\n\tget features(): StandardConnectFeature & StandardEventsFeature & SuiFeatures {\n\t\treturn {\n\t\t\t[StandardConnect]: {\n\t\t\t\tversion: '1.0.0',\n\t\t\t\tconnect: this.#connect,\n\t\t\t},\n\t\t\t[StandardEvents]: {\n\t\t\t\tversion: '1.0.0',\n\t\t\t\ton: this.#on,\n\t\t\t},\n\t\t\t[SuiSignPersonalMessage]: {\n\t\t\t\tversion: '1.1.0',\n\t\t\t\tsignPersonalMessage: this.#signPersonalMessage,\n\t\t\t},\n\t\t\t[SuiSignTransaction]: {\n\t\t\t\tversion: '2.0.0',\n\t\t\t\tsignTransaction: this.#signTransaction,\n\t\t\t},\n\t\t\t[SuiSignAndExecuteTransaction]: {\n\t\t\t\tversion: '2.0.0',\n\t\t\t\tsignAndExecuteTransaction: this.#signAndExecuteTransaction,\n\t\t\t},\n\t\t};\n\t}\n\n\t#on: StandardEventsOnMethod = () => {\n\t\treturn () => {};\n\t};\n\n\t#connect: StandardConnectMethod = async () => {\n\t\treturn { accounts: this.accounts };\n\t};\n\n\t#signPersonalMessage: SuiSignPersonalMessageMethod = async (messageInput) => {\n\t\treturn await this.#keypair.signPersonalMessage(messageInput.message);\n\t};\n\n\t#signTransaction: SuiSignTransactionMethod = async ({ transaction, signal, chain }) => {\n\t\tsignal?.throwIfAborted();\n\n\t\tconst client = this.#chainConfig[chain];\n\t\tif (!client) throw new Error(`Invalid chain \"${chain}\" specified.`);\n\n\t\tconst parsedTransaction = Transaction.from(await transaction.toJSON());\n\t\tconst builtTransaction = await parsedTransaction.build({ client });\n\t\treturn await this.#keypair.signTransaction(builtTransaction);\n\t};\n\n\t#signAndExecuteTransaction: SuiSignAndExecuteTransactionMethod = async ({\n\t\ttransaction,\n\t\tsignal,\n\t\tchain,\n\t}) => {\n\t\tsignal?.throwIfAborted();\n\n\t\tconst client = this.#chainConfig[chain];\n\t\tif (!client) throw new Error(`Invalid chain \"${chain}\" specified.`);\n\n\t\tconst parsedTransaction = Transaction.from(await transaction.toJSON());\n\t\tconst bytes = await parsedTransaction.build({ client });\n\n\t\tconst result = await this.#keypair.signAndExecuteTransaction({\n\t\t\ttransaction: parsedTransaction,\n\t\t\tclient,\n\t\t});\n\n\t\tconst tx = result.Transaction ?? result.FailedTransaction;\n\t\treturn {\n\t\t\tbytes: toBase64(bytes),\n\t\t\tsignature: tx.signatures[0],\n\t\t\tdigest: tx.digest,\n\t\t\teffects: toBase64(tx.effects.bcs!),\n\t\t};\n\t};\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { ReadableAtom } from 'nanostores';\nimport { readonlyType } from 'nanostores';\nimport type { DAppKitStores } from './store.js';\nimport { createStores } from './store.js';\nimport { syncRegisteredWallets } from './initializers/registered-wallets.js';\nimport { autoConnectWallet } from './initializers/autoconnect-wallet.js';\nimport { createInMemoryStorage, DEFAULT_STORAGE_KEY, getDefaultStorage } from '../utils/storage.js';\nimport { syncStateToStorage } from './initializers/sync-state-to-storage.js';\nimport { manageWalletConnection } from './initializers/manage-connection.js';\nimport { createNetworkConfig } from '../utils/networks.js';\nimport type { Networks } from '../utils/networks.js';\nimport type { CreateDAppKitOptions, DAppKitCompatibleClient } from './types.js';\nimport { switchNetworkCreator } from './actions/switch-network.js';\nimport type { ConnectWalletArgs } from './actions/connect-wallet.js';\nimport { connectWalletCreator } from './actions/connect-wallet.js';\nimport { disconnectWalletCreator } from './actions/disconnect-wallet.js';\nimport type { SwitchAccountArgs } from './actions/switch-account.js';\nimport { switchAccountCreator } from './actions/switch-account.js';\nimport type { SignPersonalMessageArgs } from './actions/sign-personal-message.js';\nimport { signPersonalMessageCreator } from './actions/sign-personal-message.js';\nimport type {\n\tSignAndExecuteTransactionArgs,\n\tSignAndExecuteTransactionResult,\n} from './actions/sign-and-execute-transaction.js';\nimport { signAndExecuteTransactionCreator } from './actions/sign-and-execute-transaction.js';\nimport type { SignTransactionArgs } from './actions/sign-transaction.js';\nimport { signTransactionCreator } from './actions/sign-transaction.js';\nimport { slushWebWalletInitializer } from '../wallets/slush-web.js';\nimport { registerAdditionalWallets } from '../wallets/index.js';\nimport { unsafeBurnerWalletInitializer } from '../wallets/unsafe-burner.js';\nimport type { SignedPersonalMessage, SignedTransaction } from '@mysten/wallet-standard';\nimport type { UiWalletAccount } from '@wallet-standard/ui';\n\nexport type DAppKit<\n\tTNetworks extends Networks = [],\n\tClient extends DAppKitCompatibleClient = DAppKitCompatibleClient,\n> = {\n\tnetworks: TNetworks;\n\tgetClient: (network?: TNetworks[number]) => Client;\n\tsignTransaction: (args: SignTransactionArgs) => Promise<SignedTransaction>;\n\tsignAndExecuteTransaction: (\n\t\targs: SignAndExecuteTransactionArgs,\n\t) => Promise<SignAndExecuteTransactionResult>;\n\tsignPersonalMessage: (args: SignPersonalMessageArgs) => Promise<SignedPersonalMessage>;\n\tconnectWallet: (args: ConnectWalletArgs) => Promise<{\n\t\taccounts: UiWalletAccount[];\n\t}>;\n\tdisconnectWallet: () => Promise<void>;\n\tswitchAccount: (args: SwitchAccountArgs) => void;\n\tswitchNetwork: (network: TNetworks[number]) => void;\n\tstores: {\n\t\t$wallets: DAppKitStores['$compatibleWallets'];\n\t\t$connection: DAppKitStores['$connection'];\n\t\t$currentNetwork: ReadableAtom<TNetworks[number]>;\n\t\t$currentClient: ReadableAtom<Client>;\n\t};\n};\n\nexport function createDAppKit<\n\tTNetworks extends Networks = Networks,\n\tClient extends DAppKitCompatibleClient = DAppKitCompatibleClient,\n>({\n\tautoConnect = true,\n\tnetworks,\n\tcreateClient,\n\tdefaultNetwork = networks[0],\n\tenableBurnerWallet = false,\n\tslushWalletConfig,\n\tstorage = getDefaultStorage(),\n\tstorageKey = DEFAULT_STORAGE_KEY,\n\twalletInitializers = [],\n}: CreateDAppKitOptions<TNetworks, Client>): DAppKit<TNetworks, Client> {\n\tconst networkConfig = createNetworkConfig(networks, createClient);\n\tconst stores = createStores({ defaultNetwork, getClient: networkConfig.getClient });\n\n\tfunction getClient<T extends TNetworks[number]>(network?: TNetworks[number] | T): Client {\n\t\treturn network ? networkConfig.getClient(network) : stores.$currentClient.get();\n\t}\n\n\tstorage ||= createInMemoryStorage();\n\tsyncStateToStorage({ stores, storageKey, storage });\n\n\tsyncRegisteredWallets(stores);\n\tmanageWalletConnection(stores);\n\n\tif (autoConnect) {\n\t\tautoConnectWallet({ networks, stores, storageKey, storage });\n\t}\n\n\tregisterAdditionalWallets(\n\t\t[\n\t\t\t...walletInitializers,\n\t\t\t...(enableBurnerWallet ? [unsafeBurnerWalletInitializer()] : []),\n\t\t\t...(slushWalletConfig !== null ? [slushWebWalletInitializer(slushWalletConfig)] : []),\n\t\t],\n\t\t{ networks, getClient },\n\t);\n\n\treturn {\n\t\tnetworks,\n\t\tgetClient,\n\t\tsignTransaction: signTransactionCreator(stores),\n\t\tsignAndExecuteTransaction: signAndExecuteTransactionCreator(stores),\n\t\tsignPersonalMessage: signPersonalMessageCreator(stores),\n\t\tconnectWallet: connectWalletCreator(stores, networks),\n\t\tdisconnectWallet: disconnectWalletCreator(stores),\n\t\tswitchAccount: switchAccountCreator(stores),\n\t\tswitchNetwork: switchNetworkCreator(stores),\n\t\tstores: {\n\t\t\t$wallets: stores.$compatibleWallets,\n\t\t\t$connection: stores.$connection,\n\t\t\t$currentNetwork: readonlyType(stores.$currentNetwork),\n\t\t\t$currentClient: stores.$currentClient,\n\t\t},\n\t};\n}\n"],"mappings":"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"}