import {
  classMap,
  customElement,
  property,
  query,
  state
} from "./chunk-FH3H3D5Y.js";
import {
  LitElement,
  adoptStyles,
  css,
  html,
  notEqual,
  nothing
} from "./chunk-EB74HIWG.js";
import {
  ReadonlyWalletAccount,
  SLUSH_WALLET_NAME,
  StandardConnect,
  StandardDisconnect,
  StandardEvents,
  SuiSignAndExecuteTransaction,
  SuiSignAndExecuteTransactionBlock,
  SuiSignPersonalMessage,
  SuiSignTransaction,
  SuiSignTransactionBlock,
  Transaction,
  WALLET_STANDARD_ERROR__FEATURES__WALLET_ACCOUNT_CHAIN_UNSUPPORTED,
  WALLET_STANDARD_ERROR__FEATURES__WALLET_ACCOUNT_FEATURE_UNIMPLEMENTED,
  WALLET_STANDARD_ERROR__FEATURES__WALLET_FEATURE_UNIMPLEMENTED,
  WALLET_STANDARD_ERROR__REGISTRY__WALLET_ACCOUNT_NOT_FOUND,
  WALLET_STANDARD_ERROR__REGISTRY__WALLET_NOT_FOUND,
  WALLET_STANDARD_ERROR__USER__REQUEST_REJECTED,
  WalletStandardError,
  autoPlacement,
  autoUpdate,
  computePosition,
  flip,
  formatAddress,
  getWallets,
  isWalletStandardError,
  offset,
  registerSlushWallet,
  safeCaptureStackTrace,
  shift
} from "./chunk-UIVLTKK7.js";
import {
  Ed25519Keypair
} from "./chunk-AKYQJ3JN.js";
import {
  extractStatusFromEffectsBcs,
  parseTransactionBcs,
  parseTransactionEffectsBcs
} from "./chunk-BXEU6FCI.js";
import "./chunk-LENSZOZJ.js";
import {
  fromBase64,
  normalizeSuiNSName,
  promiseWithResolvers,
  suiBcs,
  toBase64
} from "./chunk-FUHPSCUV.js";
import {
  require_jsx_runtime
} from "./chunk-SZUE23EY.js";
import {
  require_react
} from "./chunk-L6CFCVJ5.js";
import {
  __commonJS,
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __toESM
} from "./chunk-XP42M667.js";

// node_modules/.pnpm/@nanostores+lit@0.2.3_lit@3.3.2_nanostores@1.1.0/node_modules/@nanostores/lit/lib/StoreController.js
var require_StoreController = __commonJS({
  "node_modules/.pnpm/@nanostores+lit@0.2.3_lit@3.3.2_nanostores@1.1.0/node_modules/@nanostores/lit/lib/StoreController.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StoreController = void 0;
    var StoreController = class {
      constructor(host, atom2) {
        this.host = host;
        this.atom = atom2;
        host.addController(this);
      }
      // Subscribe to the atom when the host connects
      hostConnected() {
        this.unsubscribe = this.atom.subscribe(() => {
          this.host.requestUpdate();
        });
      }
      // Unsubscribe from the atom when the host disconnects
      hostDisconnected() {
        var _a9;
        (_a9 = this.unsubscribe) === null || _a9 === void 0 ? void 0 : _a9.call(this);
      }
      /**
       * The current value of the atom.
       * @readonly
       */
      get value() {
        return this.atom.get();
      }
    };
    exports.StoreController = StoreController;
  }
});

// node_modules/.pnpm/@nanostores+lit@0.2.3_lit@3.3.2_nanostores@1.1.0/node_modules/@nanostores/lit/lib/MultiStoreController.js
var require_MultiStoreController = __commonJS({
  "node_modules/.pnpm/@nanostores+lit@0.2.3_lit@3.3.2_nanostores@1.1.0/node_modules/@nanostores/lit/lib/MultiStoreController.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MultiStoreController = void 0;
    var MultiStoreController2 = class {
      constructor(host, atoms) {
        this.host = host;
        this.atoms = atoms;
        host.addController(this);
      }
      // Subscribe to the atom when the host connects
      hostConnected() {
        this.unsubscribes = this.atoms.map((atom2) => atom2.subscribe(() => this.host.requestUpdate()));
      }
      // Unsubscribe from the atom when the host disconnects
      hostDisconnected() {
        var _a9;
        (_a9 = this.unsubscribes) === null || _a9 === void 0 ? void 0 : _a9.forEach((unsubscribe) => unsubscribe());
      }
      /**
       * The current values of the atoms.
       * @readonly
       */
      get values() {
        return this.atoms.map((atom2) => atom2.get());
      }
    };
    exports.MultiStoreController = MultiStoreController2;
  }
});

// node_modules/.pnpm/@nanostores+lit@0.2.3_lit@3.3.2_nanostores@1.1.0/node_modules/@nanostores/lit/lib/useStores.js
var require_useStores = __commonJS({
  "node_modules/.pnpm/@nanostores+lit@0.2.3_lit@3.3.2_nanostores@1.1.0/node_modules/@nanostores/lit/lib/useStores.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useStores = void 0;
    var MultiStoreController_1 = require_MultiStoreController();
    function useStores(...atoms) {
      return (constructor) => {
        return class extends constructor {
          constructor(...args) {
            super(...args);
            new MultiStoreController_1.MultiStoreController(this, atoms);
          }
        };
      };
    }
    exports.useStores = useStores;
  }
});

// node_modules/.pnpm/@nanostores+lit@0.2.3_lit@3.3.2_nanostores@1.1.0/node_modules/@nanostores/lit/lib/withStores.js
var require_withStores = __commonJS({
  "node_modules/.pnpm/@nanostores+lit@0.2.3_lit@3.3.2_nanostores@1.1.0/node_modules/@nanostores/lit/lib/withStores.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.withStores = void 0;
    var MultiStoreController_1 = require_MultiStoreController();
    var withStores = (LitElementClass, atoms) => {
      return class LitElementWithStores extends LitElementClass {
        constructor(...args) {
          super(...args);
          new MultiStoreController_1.MultiStoreController(this, atoms);
        }
      };
    };
    exports.withStores = withStores;
  }
});

// node_modules/.pnpm/@nanostores+lit@0.2.3_lit@3.3.2_nanostores@1.1.0/node_modules/@nanostores/lit/lib/index.js
var require_lib = __commonJS({
  "node_modules/.pnpm/@nanostores+lit@0.2.3_lit@3.3.2_nanostores@1.1.0/node_modules/@nanostores/lit/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.withStores = exports.useStores = exports.MultiStoreController = exports.StoreController = void 0;
    var StoreController_1 = require_StoreController();
    Object.defineProperty(exports, "StoreController", { enumerable: true, get: function() {
      return StoreController_1.StoreController;
    } });
    var MultiStoreController_1 = require_MultiStoreController();
    Object.defineProperty(exports, "MultiStoreController", { enumerable: true, get: function() {
      return MultiStoreController_1.MultiStoreController;
    } });
    var useStores_1 = require_useStores();
    Object.defineProperty(exports, "useStores", { enumerable: true, get: function() {
      return useStores_1.useStores;
    } });
    var withStores_1 = require_withStores();
    Object.defineProperty(exports, "withStores", { enumerable: true, get: function() {
      return withStores_1.withStores;
    } });
  }
});

// node_modules/.pnpm/@mysten+dapp-kit-react@1.0.1_@mysten+sui@2.2.0_@types+react@19.2.10_react@19.2.4_typescript@5.9.3/node_modules/@mysten/dapp-kit-react/dist/index.mjs
var React = __toESM(require_react(), 1);
var import_react2 = __toESM(require_react(), 1);

// node_modules/.pnpm/@lit+react@1.0.8_@types+react@19.2.10/node_modules/@lit/react/development/create-component.js
var NODE_MODE = false;
var DEV_MODE = true;
var reservedReactProperties = /* @__PURE__ */ new Set([
  "children",
  "localName",
  "ref",
  "style",
  "className"
]);
var listenedEvents = /* @__PURE__ */ new WeakMap();
var addOrUpdateEventListener = (node, event, listener) => {
  let events = listenedEvents.get(node);
  if (events === void 0) {
    listenedEvents.set(node, events = /* @__PURE__ */ new Map());
  }
  let handler = events.get(event);
  if (listener !== void 0) {
    if (handler === void 0) {
      events.set(event, handler = { handleEvent: listener });
      node.addEventListener(event, handler);
    } else {
      handler.handleEvent = listener;
    }
  } else if (handler !== void 0) {
    events.delete(event);
    node.removeEventListener(event, handler);
  }
};
var setProperty = (node, name, value, old, events) => {
  const event = events?.[name];
  if (event !== void 0) {
    if (value !== old) {
      addOrUpdateEventListener(node, event, value);
    }
    return;
  }
  node[name] = value;
  if ((value === void 0 || value === null) && name in HTMLElement.prototype) {
    node.removeAttribute(name);
  }
};
var createComponent = ({ react: React2, tagName, elementClass, events, displayName }) => {
  const eventProps = new Set(Object.keys(events ?? {}));
  if (DEV_MODE && !NODE_MODE) {
    for (const p of reservedReactProperties) {
      if (p in elementClass.prototype && !(p in HTMLElement.prototype)) {
        console.warn(`${tagName} contains property ${p} which is a React reserved property. It will be used by React and not set on the element.`);
      }
    }
  }
  const ReactComponent = React2.forwardRef((props, ref) => {
    const prevElemPropsRef = React2.useRef(/* @__PURE__ */ new Map());
    const elementRef = React2.useRef(null);
    const reactProps = {};
    const elementProps = {};
    for (const [k, v] of Object.entries(props)) {
      if (reservedReactProperties.has(k)) {
        reactProps[k === "className" ? "class" : k] = v;
        continue;
      }
      if (eventProps.has(k) || k in elementClass.prototype) {
        elementProps[k] = v;
        continue;
      }
      reactProps[k] = v;
    }
    if (!NODE_MODE) {
      React2.useLayoutEffect(() => {
        if (elementRef.current === null) {
          return;
        }
        const newElemProps = /* @__PURE__ */ new Map();
        for (const key in elementProps) {
          setProperty(elementRef.current, key, props[key], prevElemPropsRef.current.get(key), events);
          prevElemPropsRef.current.delete(key);
          newElemProps.set(key, props[key]);
        }
        for (const [key, value] of prevElemPropsRef.current) {
          setProperty(elementRef.current, key, void 0, value, events);
        }
        prevElemPropsRef.current = newElemProps;
      });
      React2.useLayoutEffect(() => {
        elementRef.current?.removeAttribute("defer-hydration");
      }, []);
    }
    if (NODE_MODE) {
      if ((React2.createElement.name === "litPatchedCreateElement" || globalThis.litSsrReactEnabled) && Object.keys(elementProps).length) {
        reactProps["_$litProps$"] = elementProps;
      }
    } else {
      reactProps["suppressHydrationWarning"] = true;
    }
    return React2.createElement(tagName, {
      ...reactProps,
      ref: React2.useCallback((node) => {
        elementRef.current = node;
        if (typeof ref === "function") {
          ref(node);
        } else if (ref !== null) {
          ref.current = node;
        }
      }, [ref])
    });
  });
  ReactComponent.displayName = displayName ?? elementClass.name;
  return ReactComponent;
};

// node_modules/.pnpm/@webcomponents+scoped-custom-element-registry@0.0.10/node_modules/@webcomponents/scoped-custom-element-registry/scoped-custom-element-registry.min.js
(function() {
  "use strict";
  function k(a) {
    var b = 0;
    return function() {
      return b < a.length ? { done: false, value: a[b++] } : { done: true };
    };
  }
  var l = "function" == typeof Object.defineProperties ? Object.defineProperty : function(a, b, d) {
    if (a == Array.prototype || a == Object.prototype) return a;
    a[b] = d.value;
    return a;
  };
  function m(a) {
    a = ["object" == typeof globalThis && globalThis, a, "object" == typeof window && window, "object" == typeof self && self, "object" == typeof global && global];
    for (var b = 0; b < a.length; ++b) {
      var d = a[b];
      if (d && d.Math == Math) return d;
    }
    throw Error("Cannot find global object");
  }
  var n = m(this);
  function p(a, b) {
    if (b) a: {
      var d = n;
      a = a.split(".");
      for (var e = 0; e < a.length - 1; e++) {
        var c = a[e];
        if (!(c in d)) break a;
        d = d[c];
      }
      a = a[a.length - 1];
      e = d[a];
      b = b(e);
      b != e && null != b && l(d, a, { configurable: true, writable: true, value: b });
    }
  }
  p("Symbol", function(a) {
    function b(c) {
      if (this instanceof b) throw new TypeError("Symbol is not a constructor");
      return new d("jscomp_symbol_" + (c || "") + "_" + e++, c);
    }
    function d(c, f) {
      this.l = c;
      l(this, "description", { configurable: true, writable: true, value: f });
    }
    if (a) return a;
    d.prototype.toString = function() {
      return this.l;
    };
    var e = 0;
    return b;
  });
  p("Symbol.iterator", function(a) {
    if (a) return a;
    a = /* @__PURE__ */ Symbol("Symbol.iterator");
    for (var b = "Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "), d = 0; d < b.length; d++) {
      var e = n[b[d]];
      "function" === typeof e && "function" != typeof e.prototype[a] && l(e.prototype, a, { configurable: true, writable: true, value: function() {
        return aa(k(this));
      } });
    }
    return a;
  });
  function aa(a) {
    a = { next: a };
    a[Symbol.iterator] = function() {
      return this;
    };
    return a;
  }
  function q(a) {
    var b = "undefined" != typeof Symbol && Symbol.iterator && a[Symbol.iterator];
    return b ? b.call(a) : { next: k(a) };
  }
  function r(a) {
    if (!(a instanceof Array)) {
      a = q(a);
      for (var b, d = []; !(b = a.next()).done; ) d.push(b.value);
      a = d;
    }
    return a;
  }
  var t = "function" == typeof Object.create ? Object.create : function(a) {
    function b() {
    }
    b.prototype = a;
    return new b();
  }, ba = (function() {
    function a() {
      function d() {
      }
      new d();
      Reflect.construct(d, [], function() {
      });
      return new d() instanceof d;
    }
    if ("undefined" != typeof Reflect && Reflect.construct) {
      if (a()) return Reflect.construct;
      var b = Reflect.construct;
      return function(d, e, c) {
        d = b(d, e);
        c && Reflect.setPrototypeOf(d, c.prototype);
        return d;
      };
    }
    return function(d, e, c) {
      void 0 === c && (c = d);
      c = t(c.prototype || Object.prototype);
      return Function.prototype.apply.call(
        d,
        c,
        e
      ) || c;
    };
  })(), v;
  if ("function" == typeof Object.setPrototypeOf) v = Object.setPrototypeOf;
  else {
    var w;
    a: {
      var ca = { a: true }, x = {};
      try {
        x.__proto__ = ca;
        w = x.a;
        break a;
      } catch (a) {
      }
      w = false;
    }
    v = w ? function(a, b) {
      a.__proto__ = b;
      if (a.__proto__ !== b) throw new TypeError(a + " is not extensible");
      return a;
    } : null;
  }
  var y = v, z = window, A;
  if (void 0 === (null == (A = z.CustomElementRegistryPolyfill) ? void 0 : A.formAssociated)) {
    var B = {};
    z.CustomElementRegistryPolyfill = (B.formAssociated = /* @__PURE__ */ new Set(), B);
  }
  var C = window.HTMLElement, da = window.customElements.define, ea = window.customElements.get, D = window.customElements, E = /* @__PURE__ */ new WeakMap(), F = /* @__PURE__ */ new WeakMap(), G = /* @__PURE__ */ new WeakMap(), H = /* @__PURE__ */ new WeakMap();
  function fa() {
    var a;
    this.promise = new Promise(function(b) {
      a = b;
    });
    this.resolve = a;
  }
  function I() {
    this.h = /* @__PURE__ */ new Map();
    this.m = /* @__PURE__ */ new Map();
    this.j = /* @__PURE__ */ new Map();
    this.i = /* @__PURE__ */ new Map();
  }
  I.prototype.define = function(a, b) {
    a = a.toLowerCase();
    if (void 0 !== this.h.get(a)) throw new DOMException(`Failed to execute 'define' on 'CustomElementRegistry': the name "` + a + '" has already been used with this registry');
    if (void 0 !== this.m.get(b)) throw new DOMException("Failed to execute 'define' on 'CustomElementRegistry': this constructor has already been used with this registry");
    var d = b.prototype.attributeChangedCallback, e = new Set(b.observedAttributes || []);
    ha(b, e, d);
    var c = ea.call(D, a), f, g, h = null != (g = null == (f = c) ? void 0 : f.s) ? g : b.formAssociated || z.CustomElementRegistryPolyfill.formAssociated.has(a);
    h && z.CustomElementRegistryPolyfill.formAssociated.add(a);
    if (h != b.formAssociated) try {
      b.formAssociated = h;
    } catch (u) {
    }
    d = {
      tagName: a,
      g: b,
      connectedCallback: b.prototype.connectedCallback,
      disconnectedCallback: b.prototype.disconnectedCallback,
      adoptedCallback: b.prototype.adoptedCallback,
      attributeChangedCallback: d,
      formAssociated: h,
      formAssociatedCallback: b.prototype.formAssociatedCallback,
      formDisabledCallback: b.prototype.formDisabledCallback,
      formResetCallback: b.prototype.formResetCallback,
      formStateRestoreCallback: b.prototype.formStateRestoreCallback,
      observedAttributes: e
    };
    this.h.set(a, d);
    this.m.set(b, d);
    c || (c = ia(a), da.call(D, a, c));
    this === window.customElements && (G.set(b, d), d.o = c);
    if (c = this.i.get(a)) for (this.i.delete(a), c = q(c), e = c.next(); !e.done; e = c.next()) e = e.value, F.delete(e), J(e, d, true);
    c = this.j.get(a);
    void 0 !== c && (c.resolve(b), this.j.delete(a));
    return b;
  };
  I.prototype.upgrade = function(a) {
    for (var b = [], d = 0; d < arguments.length; ++d) b[d] = arguments[d];
    K.push(this);
    D.upgrade.apply(D, r(b));
    K.pop();
  };
  I.prototype.get = function(a) {
    var b;
    return null == (b = this.h.get(a)) ? void 0 : b.g;
  };
  I.prototype.whenDefined = function(a) {
    var b = this.h.get(a);
    if (void 0 !== b) return Promise.resolve(b.g);
    b = this.j.get(a);
    void 0 === b && (b = new fa(), this.j.set(a, b));
    return b.promise;
  };
  function L(a, b, d, e) {
    var c = a.i.get(d);
    c || a.i.set(d, c = /* @__PURE__ */ new Set());
    e ? c.add(b) : c.delete(b);
  }
  var M;
  window.HTMLElement = function() {
    var a = M;
    if (a) return M = void 0, a;
    var b = G.get(this.constructor);
    if (!b) throw new TypeError("Illegal constructor (custom element class must be registered with global customElements registry to be newable)");
    a = Reflect.construct(C, [], b.o);
    Object.setPrototypeOf(a, this.constructor.prototype);
    E.set(a, b);
    return a;
  };
  window.HTMLElement.prototype = C.prototype;
  function ia(a) {
    function b() {
      var d = Reflect.construct(C, [], this.constructor);
      Object.setPrototypeOf(d, HTMLElement.prototype);
      a: {
        var e = d.getRootNode();
        if (!(e === document || e instanceof ShadowRoot)) {
          e = K[K.length - 1];
          if (e instanceof CustomElementRegistry) {
            var c = e;
            break a;
          }
          e = e.getRootNode();
          e === document || e instanceof ShadowRoot || (e = (null == (c = H.get(e)) ? void 0 : c.getRootNode()) || document);
        }
        c = e.registry;
      }
      c = c || window.customElements;
      (e = c.h.get(a)) ? J(d, e) : F.set(d, c);
      return d;
    }
    n.Object.defineProperty(
      b,
      "formAssociated",
      { configurable: true, enumerable: true, get: function() {
        return z.CustomElementRegistryPolyfill.formAssociated.has(a);
      } }
    );
    b.prototype.connectedCallback = function(d) {
      for (var e = [], c = 0; c < arguments.length; ++c) e[c] = arguments[c];
      N(this);
      (c = E.get(this)) ? c.connectedCallback && c.connectedCallback.apply(this, e) : L(F.get(this), this, a, true);
    };
    b.prototype.disconnectedCallback = function(d) {
      for (var e = [], c = 0; c < arguments.length; ++c) e[c] = arguments[c];
      (c = E.get(this)) ? c.disconnectedCallback && c.disconnectedCallback.apply(this, e) : L(
        F.get(this),
        this,
        a,
        false
      );
    };
    b.prototype.adoptedCallback = function(d) {
      for (var e = [], c = 0; c < arguments.length; ++c) e[c] = arguments[c];
      var f, g;
      null == (f = E.get(this)) || null == (g = f.adoptedCallback) || g.apply(this, e);
    };
    b.prototype.formAssociatedCallback = function(d) {
      for (var e = [], c = 0; c < arguments.length; ++c) e[c] = arguments[c];
      c = E.get(this);
      if (null == c ? 0 : c.formAssociated) {
        var f;
        null == c || null == (f = c.formAssociatedCallback) || f.apply(this, e);
      }
    };
    b.prototype.formDisabledCallback = function(d) {
      for (var e = [], c = 0; c < arguments.length; ++c) e[c] = arguments[c];
      c = E.get(this);
      if (null == c ? 0 : c.formAssociated) {
        var f;
        null == c || null == (f = c.formDisabledCallback) || f.apply(this, e);
      }
    };
    b.prototype.formResetCallback = function(d) {
      for (var e = [], c = 0; c < arguments.length; ++c) e[c] = arguments[c];
      c = E.get(this);
      if (null == c ? 0 : c.formAssociated) {
        var f;
        null == c || null == (f = c.formResetCallback) || f.apply(this, e);
      }
    };
    b.prototype.formStateRestoreCallback = function(d) {
      for (var e = [], c = 0; c < arguments.length; ++c) e[c] = arguments[c];
      c = E.get(this);
      if (null == c ? 0 : c.formAssociated) {
        var f;
        null == c || null == (f = c.formStateRestoreCallback) || f.apply(this, e);
      }
    };
    return b;
  }
  window.CustomElementRegistry = I;
  function ha(a, b, d) {
    if (0 !== b.size && void 0 !== d) {
      var e = a.prototype.setAttribute;
      e && (a.prototype.setAttribute = function(g, h) {
        N(this);
        g = g.toLowerCase();
        if (b.has(g)) {
          var u = this.getAttribute(g);
          e.call(this, g, h);
          d.call(this, g, u, h);
        } else e.call(this, g, h);
      });
      var c = a.prototype.removeAttribute;
      c && (a.prototype.removeAttribute = function(g) {
        N(this);
        g = g.toLowerCase();
        if (b.has(g)) {
          var h = this.getAttribute(g);
          c.call(this, g);
          d.call(this, g, h, null);
        } else c.call(this, g);
      });
      var f = a.prototype.toggleAttribute;
      f && (a.prototype.toggleAttribute = function(g, h) {
        N(this);
        g = g.toLowerCase();
        if (b.has(g)) {
          var u = this.getAttribute(g);
          f.call(this, g, h);
          h = this.getAttribute(g);
          u !== h && d.call(this, g, u, h);
        } else f.call(this, g, h);
      });
    }
  }
  var O;
  "loading" === document.readyState && (O = /* @__PURE__ */ new Set(), document.addEventListener("readystatechange", function() {
    O.forEach(function(a) {
      return P(a, E.get(a));
    });
  }, { once: true }));
  function N(a) {
    var b;
    null != (b = O) && b.has(a) && P(a, E.get(a));
  }
  function P(a, b) {
    var d;
    null == (d = O) || d.delete(a);
    b.attributeChangedCallback && b.observedAttributes.forEach(function(e) {
      a.hasAttribute(e) && b.attributeChangedCallback.call(a, e, null, a.getAttribute(e));
    });
  }
  function Q(a) {
    var b = Object.getPrototypeOf(a);
    if (b !== window.HTMLElement) return b === C ? Object.setPrototypeOf(a, window.HTMLElement) : Q(b);
  }
  function J(a, b, d) {
    d = void 0 === d ? false : d;
    Object.setPrototypeOf(a, b.g.prototype);
    E.set(a, b);
    M = a;
    try {
      new b.g();
    } catch (e) {
      Q(b.g), new b.g();
    }
    b.attributeChangedCallback && (void 0 === O || a.hasAttributes() ? P(a, b) : O.add(a));
    d && b.connectedCallback && a.isConnected && b.connectedCallback.call(a);
  }
  var R = Element.prototype.attachShadow;
  Element.prototype.attachShadow = function(a, b) {
    for (var d = [], e = 1; e < arguments.length; ++e) d[e - 1] = arguments[e];
    var c = Object.assign({}, a);
    e = a.customElements;
    e = void 0 === a.registry ? e : a.registry;
    c = (delete c.customElements, delete c.registry, c);
    d = R.call.apply(R, [this, c].concat(r(d)));
    void 0 !== e && (d.customElements = d.registry = e);
    return d;
  };
  var K = [document];
  function S(a, b, d) {
    var e = (d ? Object.getPrototypeOf(d) : a.prototype)[b];
    a.prototype[b] = function(c) {
      for (var f = [], g = 0; g < arguments.length; ++g) f[g] = arguments[g];
      K.push(this);
      f = e.apply(d || this, f);
      void 0 !== f && H.set(f, this);
      K.pop();
      return f;
    };
  }
  S(ShadowRoot, "createElement", document);
  S(ShadowRoot, "createElementNS", document);
  S(ShadowRoot, "importNode", document);
  S(Element, "insertAdjacentHTML");
  function T(a) {
    var b = Object.getOwnPropertyDescriptor(a.prototype, "innerHTML");
    Object.defineProperty(a.prototype, "innerHTML", Object.assign({}, b, { set: function(d) {
      K.push(this);
      b.set.call(this, d);
      K.pop();
    } }));
  }
  T(Element);
  T(ShadowRoot);
  Object.defineProperty(window, "customElements", { value: new CustomElementRegistry(), configurable: true, writable: true });
  if (window.ElementInternals && window.ElementInternals.prototype.setFormValue) {
    var U = /* @__PURE__ */ new WeakMap(), V = HTMLElement.prototype.attachInternals, methods = ["setFormValue", "setValidity", "checkValidity", "reportValidity"];
    HTMLElement.prototype.attachInternals = function(a) {
      for (var b = [], d = 0; d < arguments.length; ++d) b[d] = arguments[d];
      b = V.call.apply(V, [this].concat(r(b)));
      U.set(b, this);
      return b;
    };
    methods.forEach(function(a) {
      var b = window.ElementInternals.prototype, d = b[a];
      b[a] = function(e) {
        for (var c = [], f = 0; f < arguments.length; ++f) c[f] = arguments[f];
        f = U.get(this);
        if (true === E.get(f).formAssociated) return null == d ? void 0 : d.call.apply(d, [this].concat(r(c)));
        throw new DOMException("Failed to execute " + d + " on 'ElementInternals': The target element is not a form-associated custom element.");
      };
    });
    var RadioNodeList = function(a) {
      var b = ba(Array, [].concat(r(a)), this.constructor);
      b.l = a;
      return b;
    }, W = RadioNodeList, X = Array;
    W.prototype = t(X.prototype);
    W.prototype.constructor = W;
    if (y) y(W, X);
    else for (var Y in X) if ("prototype" != Y) if (Object.defineProperties) {
      var Z = Object.getOwnPropertyDescriptor(X, Y);
      Z && Object.defineProperty(W, Y, Z);
    } else W[Y] = X[Y];
    W.u = X.prototype;
    n.Object.defineProperty(RadioNodeList.prototype, "value", { configurable: true, enumerable: true, get: function() {
      var a;
      return (null == (a = this.l.find(function(b) {
        return true === b.checked;
      })) ? void 0 : a.value) || "";
    } });
    var HTMLFormControlsCollection = function(a) {
      var b = this, d = /* @__PURE__ */ new Map();
      a.forEach(function(e, c) {
        var f = e.getAttribute("name"), g = d.get(f) || [];
        b[+c] = e;
        g.push(e);
        d.set(f, g);
      });
      this.length = a.length;
      d.forEach(function(e, c) {
        e && "length" !== c && "item" !== c && "namedItem" !== c && (b[c] = 1 === e.length ? e[0] : new RadioNodeList(e));
      });
    };
    HTMLFormControlsCollection.prototype.item = function(a) {
      var b;
      return null != (b = this[a]) ? b : null;
    };
    HTMLFormControlsCollection.prototype[Symbol.iterator] = function() {
      throw Error("Method not implemented.");
    };
    HTMLFormControlsCollection.prototype.namedItem = function(a) {
      var b;
      return null != (b = this[a]) ? b : null;
    };
    var ja = Object.getOwnPropertyDescriptor(HTMLFormElement.prototype, "elements");
    Object.defineProperty(
      HTMLFormElement.prototype,
      "elements",
      { get: function() {
        var a = ja.get.call(this), b = [];
        a = q(a);
        for (var d = a.next(); !d.done; d = a.next()) {
          d = d.value;
          var e = E.get(d);
          e && true !== e.formAssociated || b.push(d);
        }
        return new HTMLFormControlsCollection(b);
      } }
    );
  }
  ;
}).call(typeof globalThis === "object" ? globalThis : window);

// node_modules/.pnpm/@mysten+dapp-kit-core@1.0.2_@mysten+sui@2.2.0_typescript@5.9.3/node_modules/@mysten/dapp-kit-core/dist/web/index.mjs
var import_lit2 = __toESM(require_lib(), 1);

// node_modules/.pnpm/@lit-labs+scoped-registry-mixin@1.0.4/node_modules/@lit-labs/scoped-registry-mixin/development/scoped-registry-mixin.js
function ScopedRegistryHost(superclass) {
  return class ScopedRegistryMixin extends superclass {
    createRenderRoot() {
      const constructor = this.constructor;
      const { registry, elementDefinitions, shadowRootOptions } = constructor;
      if (elementDefinitions && !registry) {
        constructor.registry = new CustomElementRegistry();
        Object.entries(elementDefinitions).forEach(([tagName, klass]) => constructor.registry.define(tagName, klass));
      }
      const renderRoot = this.renderOptions.creationScope = this.attachShadow({
        ...shadowRootOptions,
        customElements: constructor.registry
      });
      adoptStyles(renderRoot, this.constructor.elementStyles);
      return renderRoot;
    }
  };
}

// node_modules/.pnpm/lit-html@3.3.2/node_modules/lit-html/development/directives/when.js
function when(condition, trueCase, falseCase) {
  return condition ? trueCase(condition) : falseCase?.(condition);
}

// node_modules/.pnpm/@lit+task@1.0.3/node_modules/@lit/task/development/task.js
var TaskStatus = {
  INITIAL: 0,
  PENDING: 1,
  COMPLETE: 2,
  ERROR: 3
};
var initialState = /* @__PURE__ */ Symbol();
var Task = class {
  /**
   * A Promise that resolve when the current task run is complete.
   *
   * If a new task run is started while a previous run is pending, the Promise
   * is kept and only resolved when the new run is completed.
   */
  get taskComplete() {
    if (this._taskComplete) {
      return this._taskComplete;
    }
    if (this._status === TaskStatus.PENDING) {
      this._taskComplete = new Promise((res, rej) => {
        this._resolveTaskComplete = res;
        this._rejectTaskComplete = rej;
      });
    } else if (this._status === TaskStatus.ERROR) {
      this._taskComplete = Promise.reject(this._error);
    } else {
      this._taskComplete = Promise.resolve(this._value);
    }
    return this._taskComplete;
  }
  constructor(host, task2, args) {
    this._callId = 0;
    this._status = TaskStatus.INITIAL;
    (this._host = host).addController(this);
    const taskConfig = typeof task2 === "object" ? task2 : { task: task2, args };
    this._task = taskConfig.task;
    this._argsFn = taskConfig.args;
    this._argsEqual = taskConfig.argsEqual ?? shallowArrayEquals;
    this._onComplete = taskConfig.onComplete;
    this._onError = taskConfig.onError;
    this.autoRun = taskConfig.autoRun ?? true;
    if ("initialValue" in taskConfig) {
      this._value = taskConfig.initialValue;
      this._status = TaskStatus.COMPLETE;
      this._previousArgs = this._getArgs?.();
    }
  }
  hostUpdate() {
    if (this.autoRun === true) {
      this._performTask();
    }
  }
  hostUpdated() {
    if (this.autoRun === "afterUpdate") {
      this._performTask();
    }
  }
  _getArgs() {
    if (this._argsFn === void 0) {
      return void 0;
    }
    const args = this._argsFn();
    if (!Array.isArray(args)) {
      throw new Error("The args function must return an array");
    }
    return args;
  }
  /**
   * Determines if the task should run when it's triggered because of a
   * host update, and runs the task if it should.
   *
   * A task should run when its arguments change from the previous run, based on
   * the args equality function.
   *
   * This method is side-effectful: it stores the new args as the previous args.
   */
  async _performTask() {
    const args = this._getArgs();
    const prev = this._previousArgs;
    this._previousArgs = args;
    if (args !== prev && args !== void 0 && (prev === void 0 || !this._argsEqual(prev, args))) {
      await this.run(args);
    }
  }
  /**
   * Runs a task manually.
   *
   * This can be useful for running tasks in response to events as opposed to
   * automatically running when host element state changes.
   *
   * @param args an optional set of arguments to use for this task run. If args
   *     is not given, the args function is called to get the arguments for
   *     this run.
   */
  async run(args) {
    args ??= this._getArgs();
    this._previousArgs = args;
    if (this._status === TaskStatus.PENDING) {
      this._abortController?.abort();
    } else {
      this._taskComplete = void 0;
      this._resolveTaskComplete = void 0;
      this._rejectTaskComplete = void 0;
    }
    this._status = TaskStatus.PENDING;
    let result;
    let error;
    if (this.autoRun === "afterUpdate") {
      queueMicrotask(() => this._host.requestUpdate());
    } else {
      this._host.requestUpdate();
    }
    const key = ++this._callId;
    this._abortController = new AbortController();
    let errored = false;
    try {
      result = await this._task(args, { signal: this._abortController.signal });
    } catch (e) {
      errored = true;
      error = e;
    }
    if (this._callId === key) {
      if (result === initialState) {
        this._status = TaskStatus.INITIAL;
      } else {
        if (errored === false) {
          try {
            this._onComplete?.(result);
          } catch {
          }
          this._status = TaskStatus.COMPLETE;
          this._resolveTaskComplete?.(result);
        } else {
          try {
            this._onError?.(error);
          } catch {
          }
          this._status = TaskStatus.ERROR;
          this._rejectTaskComplete?.(error);
        }
        this._value = result;
        this._error = error;
      }
      this._host.requestUpdate();
    }
  }
  /**
   * Aborts the currently pending task run by aborting the AbortSignal
   * passed to the task function.
   *
   * Aborting a task does nothing if the task is not running: ie, in the
   * complete, error, or initial states.
   *
   * Aborting a task does not automatically cancel the task function. The task
   * function must be written to accept the AbortSignal and either forward it
   * to other APIs like `fetch()`, or handle cancellation manually by using
   * [`signal.throwIfAborted()`]{@link https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal/throwIfAborted}
   * or the
   * [`abort`]{@link https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal/abort_event}
   * event.
   *
   * @param reason The reason for aborting. Passed to
   *     `AbortController.abort()`.
   */
  abort(reason) {
    if (this._status === TaskStatus.PENDING) {
      this._abortController?.abort(reason);
    }
  }
  /**
   * The result of the previous task run, if it resolved.
   *
   * Is `undefined` if the task has not run yet, or if the previous run errored.
   */
  get value() {
    return this._value;
  }
  /**
   * The error from the previous task run, if it rejected.
   *
   * Is `undefined` if the task has not run yet, or if the previous run
   * completed successfully.
   */
  get error() {
    return this._error;
  }
  get status() {
    return this._status;
  }
  render(renderer) {
    switch (this._status) {
      case TaskStatus.INITIAL:
        return renderer.initial?.();
      case TaskStatus.PENDING:
        return renderer.pending?.();
      case TaskStatus.COMPLETE:
        return renderer.complete?.(this.value);
      case TaskStatus.ERROR:
        return renderer.error?.(this.error);
      default:
        throw new Error(`Unexpected status: ${this._status}`);
    }
  }
};
var shallowArrayEquals = (oldArgs, newArgs) => oldArgs === newArgs || oldArgs.length === newArgs.length && oldArgs.every((v, i) => !notEqual(v, newArgs[i]));

// node_modules/.pnpm/@mysten+dapp-kit-core@1.0.2_@mysten+sui@2.2.0_typescript@5.9.3/node_modules/@mysten/dapp-kit-core/dist/web/index.mjs
function storeProperty() {
  return function(target, propertyKey) {
    const controllerKey = /* @__PURE__ */ Symbol();
    const valueKey = /* @__PURE__ */ Symbol();
    Object.defineProperty(target, propertyKey, {
      get() {
        return this[valueKey];
      },
      set(newInstance) {
        const oldInstance = this[valueKey];
        if (oldInstance === newInstance) return;
        this[valueKey] = newInstance;
        const existingController = this[controllerKey];
        if (existingController) {
          existingController.hostDisconnected();
          this.removeController(existingController);
        }
        const newController = newInstance ? new import_lit2.MultiStoreController(this, Object.values(newInstance.stores)) : void 0;
        this[controllerKey] = newController;
        if (existingController && !newController) this.requestUpdate(propertyKey, oldInstance);
      },
      configurable: true,
      enumerable: true
    });
  };
}
var resetStyles = css`
	* {
		box-sizing: border-box;
		-webkit-font-smoothing: antialiased;
		font-family: var(--dapp-kit-font-sans);
		outline-color: color-mix(in oklab, var(--dapp-kit-ring) 50%, transparent);
	}

	button {
		appearance: none;
		background-color: transparent;
		font-size: inherit;
		font-family: inherit;
		line-height: inherit;
		letter-spacing: inherit;
		color: inherit;
		border: 0;
		padding: 0;
		margin: 0;
	}

	ul {
		list-style: none;
		margin: 0;
		padding: 0;
	}

	p,
	h1,
	h2,
	h3,
	h4,
	h5,
	h6 {
		font-size: inherit;
		font-weight: inherit;
		color: var(--dapp-kit-foreground);
		margin: 0;
	}
`;
var themeStyles = css`
	:host {
		/** Colors */
		--dapp-kit-background: var(--background, oklch(1 0 0));
		--dapp-kit-foreground: var(--foreground, oklch(0.145 0 0));
		--dapp-kit-primary: var(--primary, oklch(0.216 0.006 56.043));
		--dapp-kit-primary-foreground: var(--primary-foreground, oklch(0.985 0.001 106.423));
		--dapp-kit-secondary: var(--secondary, oklch(0.97 0.001 106.424));
		--dapp-kit-secondary-foreground: var(--secondary-foreground, oklch(0.216 0.006 56.043));
		--dapp-kit-border: var(--border, oklch(0.922 0 0));
		--dapp-kit-accent: var(--accent, oklch(0.97 0.001 106.424));
		--dapp-kit-accent-foreground: var(--accent-foreground, oklch(0.205 0 0));
		--dapp-kit-muted: var(--muted, oklch(0.97 0.001 106.424));
		--dapp-kit-muted-foreground: var(--muted-foreground, oklch(0.553 0.013 58.071));
		--dapp-kit-popover: var(--popover, oklch(1 0 0));
		--dapp-kit-popover-foreground: var(--popover-foreground, oklch(0.145 0 0));
		--dapp-kit-destructive: var(--destructive, oklch(0.577 0.245 27.325));
		--dapp-kit-positive: var(--positive, oklch(0.862 0.127 146.2));
		--dapp-kit-ring: var(--ring, oklch(0.708 0 0));
		--dapp-kit-input: var(--input, oklch(0.922 0 0));

		/** Radii */
		--dapp-kit-radius: var(--radius, 12px);
		--dapp-kit-radius-xs: calc(var(--dapp-kit-radius) - 4px);
		--dapp-kit-radius-sm: calc(var(--dapp-kit-radius) - 4px);
		--dapp-kit-radius-md: calc(var(--dapp-kit-radius) - 2px);
		--dapp-kit-radius-lg: var(--dapp-kit-radius);
		--dapp-kit-radius-xl: calc(var(--dapp-kit-radius) + 4px);

		/** Typography */
		--dapp-kit-font-sans: var(
			--font-sans,
			ui-sans-serif,
			system-ui,
			-apple-system,
			BlinkMacSystemFont,
			'Segoe UI',
			Roboto,
			'Helvetica Neue',
			Arial,
			'Noto Sans',
			sans-serif,
			'Apple Color Emoji',
			'Segoe UI Emoji',
			'Segoe UI Symbol',
			'Noto Color Emoji'
		);
		--dapp-kit-font-weight-medium: var(--font-medium, 500);
		--dapp-kit-font-weight-semibold: var(--font-semibold, 600);
	}
`;
var sharedStyles = [themeStyles, resetStyles];
var styles$5 = [sharedStyles, css`
		.wallet-button {
			transition-property: background-color;
			transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
			transition-duration: 0.15s;
			text-decoration: none;
			background-color: var(--dapp-kit-secondary);
			border-radius: var(--dapp-kit-radius-lg);
			display: flex;
			align-items: center;
			gap: 12px;
			width: 100%;
			padding: 12px;
		}

		.wallet-button:hover {
			background-color: oklab(from var(--dapp-kit-secondary) calc(l - 0.01) a b);
		}

		img {
			width: 32px;
			height: 32px;
			border-radius: var(--dapp-kit-radius-lg);
		}

		p {
			overflow: hidden;
			white-space: nowrap;
			text-overflow: ellipsis;
			font-weight: var(--dapp-kit-font-weight-medium);
		}
	`];
function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var __this_instances, walletClicked_fn, _a;
var WalletListItem = (_a = class extends LitElement {
  constructor(..._args) {
    super(..._args);
    __privateAdd(this, __this_instances);
    this.autofocus = false;
  }
  render() {
    return html`
			<li>
				<button
					type="button"
					class="wallet-button"
					@click=${__privateMethod(this, __this_instances, walletClicked_fn)}
					?autofocus=${this.autofocus}
				>
					<img src=${this.wallet.icon} alt=${`${this.wallet.name} logo`} />
					<p>${this.wallet.name}</p>
				</button>
			</li>
		`;
  }
}, __this_instances = new WeakSet(), walletClicked_fn = function() {
  this.dispatchEvent(new CustomEvent("wallet-selected", {
    detail: { wallet: this.wallet },
    bubbles: true,
    composed: true
  }));
}, _a.styles = styles$5, _a);
__decorate([property()], WalletListItem.prototype, "wallet", void 0);
__decorate([property({
  type: Boolean,
  reflect: true
})], WalletListItem.prototype, "autofocus", void 0);
var styles$4 = [sharedStyles, css`
		:host {
			display: flex;
			flex-direction: column;
			flex-grow: 1;
		}

		ul {
			display: flex;
			flex-direction: column;
			gap: 12px;
		}

		.no-wallets-container {
			display: flex;
			flex-direction: column;
			flex-grow: 1;
		}

		.no-wallets-content {
			display: flex;
			flex-direction: column;
			align-items: center;
			justify-content: center;
			flex-grow: 1;
			gap: 32px;
		}

		.title {
			font-weight: var(--dapp-kit-font-weight-semibold);
			text-align: center;
			font-size: 28px;
		}

		.wallet-cta {
			display: flex;
			flex-direction: column;
			width: 100%;
		}
	`];
var styles$3 = [sharedStyles, css`
		.button {
			transition-property: background-color;
			transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
			transition-duration: 0.15s;
			border-radius: var(--dapp-kit-radius-md);
			font-weight: var(--dapp-kit-font-weight-semibold);
			text-decoration: none;
			outline-style: none;
			display: inline-flex;
			justify-content: center;
			align-items: center;
			gap: 12px;
			padding-left: 16px;
			padding-right: 16px;
			padding-top: 8px;
			padding-bottom: 8px;
			height: 40px;
		}

		.button:focus-visible {
			border-color: var(--dapp-kit-ring);
			box-shadow:
				0 0 0 3px color-mix(in oklab, var(--dapp-kit-ring) 50%, transparent),
				rgba(0, 0, 0, 0.05) 0px 1px 2px 0px;
		}

		.button.primary {
			background-color: var(--dapp-kit-primary);
			color: var(--dapp-kit-primary-foreground);
		}

		.button.primary:hover:not(:disabled) {
			background-color: color-mix(in oklab, var(--dapp-kit-primary) 90%, transparent);
		}

		.button.secondary {
			background-color: var(--dapp-kit-secondary);
			color: var(--dapp-kit-secondary-foreground);
		}

		.button.secondary:hover:not(:disabled) {
			background-color: color-mix(in oklab, var(--dapp-kit-secondary) 80%, transparent);
		}
	`];
var _a2;
var Button = (_a2 = class extends LitElement {
  constructor(..._args) {
    super(..._args);
    this.variant = "primary";
    this.href = "";
    this.disabled = false;
  }
  render() {
    return this.href ? html`
					<a
						href=${this.href}
						?disabled=${this.disabled}
						target="_blank"
						rel="noreferrer"
						class=${classMap({
      button: true,
      [this.variant]: true
    })}
					>
						<slot part="button-content"></slot>
					</a>
				` : html`
					<button
						type="button"
						?disabled=${this.disabled}
						class=${classMap({
      button: true,
      [this.variant]: true
    })}
					>
						<slot part="button-content"></slot>
					</button>
				`;
  }
}, _a2.shadowRootOptions = {
  ...LitElement.shadowRootOptions,
  delegatesFocus: true
}, _a2.styles = styles$3, _a2);
__decorate([property({ type: String })], Button.prototype, "variant", void 0);
__decorate([property({ type: String })], Button.prototype, "href", void 0);
__decorate([property({
  type: Boolean,
  reflect: true
})], Button.prototype, "disabled", void 0);
var downloadIcon = html`<svg
	width="80"
	height="80"
	viewBox="0 0 80 80"
	fill="none"
	xmlns="http://www.w3.org/2000/svg"
>
	<path
		d="M0 40C0 17.9086 17.9086 0 40 0C62.0914 0 80 17.9086 80 40C80 62.0914 62.0914 80 40 80C17.9086 80 0 62.0914 0 40Z"
		fill="currentColor"
		fill-opacity="0.08"
	/>
	<path
		fill-rule="evenodd"
		clip-rule="evenodd"
		d="M39.6881 28.8311C39.4347 28.9111 39.1675 29.1669 39.0607 29.4318L39.0041 29.572L38.9977 35.5349L38.9914 41.4978L37.8217 40.3324C36.5477 39.063 36.5486 39.0637 36.228 39.0138C35.7909 38.9458 35.3452 39.1858 35.1541 39.592C35.0986 39.7101 35.0921 39.7532 35.0921 40C35.0921 40.4608 34.9004 40.2321 37.3099 42.6471C39.1553 44.4968 39.4299 44.763 39.5579 44.8263C39.8344 44.9632 40.1614 44.9624 40.4441 44.8244C40.5705 44.7626 40.843 44.4987 42.679 42.659C45.0881 40.2451 44.9081 40.4599 44.9081 40C44.9081 39.7458 44.9027 39.7132 44.8403 39.586C44.6384 39.1748 44.2051 38.9438 43.7678 39.0142C43.4501 39.0654 43.4497 39.0657 42.1784 40.3324L41.0087 41.4978L41.0024 35.5349L40.9961 29.572L40.9395 29.4318C40.8294 29.1587 40.5615 28.9075 40.2964 28.8288C40.1444 28.7836 39.8347 28.7848 39.6881 28.8311ZM31.114 46.0981C30.9593 46.1346 30.7812 46.2398 30.647 46.374C30.4216 46.5994 30.3357 46.8708 30.3627 47.272C30.3949 47.7507 30.4603 48.0732 30.6081 48.484C31.0707 49.7693 32.1522 50.7474 33.4841 51.0852C33.9919 51.2141 33.6619 51.2078 39.9943 51.2079C46.331 51.208 46.0036 51.2142 46.5161 51.085C47.8428 50.7503 48.9303 49.7668 49.392 48.484C49.5851 47.9478 49.6896 47.2429 49.6266 46.9026C49.5428 46.4495 49.1756 46.1129 48.7285 46.0791C48.3302 46.0489 47.9715 46.2363 47.7705 46.5793C47.687 46.7218 47.6625 46.8267 47.6335 47.1663C47.5846 47.7384 47.4064 48.16 47.0574 48.5289C46.6981 48.9088 46.2476 49.1338 45.7272 49.1934C45.5791 49.2103 43.6721 49.2161 39.8441 49.2112L34.1801 49.204L33.9966 49.1516C33.5867 49.0347 33.3159 48.8845 33.0317 48.6166C32.6281 48.2363 32.4192 47.7806 32.3667 47.1663C32.3377 46.8267 32.3132 46.7218 32.2297 46.5793C32.1479 46.4397 31.9572 46.2518 31.8327 46.1882C31.6225 46.0807 31.3388 46.0451 31.114 46.0981Z"
		fill="currentColor"
	/>
</svg>`;
var arrowRightUpIcon = html`<svg
	width="17"
	height="16"
	viewBox="0 0 17 16"
	fill="none"
	xmlns="http://www.w3.org/2000/svg"
>
	<path
		fill-rule="evenodd"
		clip-rule="evenodd"
		d="M4.19888 1.05645C4.0026 1.08501 3.7911 1.24624 3.706 1.43215C3.62348 1.61237 3.62622 1.84103 3.71297 2.01403C3.79982 2.18722 3.99089 2.3325 4.17827 2.36781C4.23528 2.37855 5.77091 2.38405 8.71417 2.38405H13.1639L7.41745 8.13205C2.23561 13.3153 1.66614 13.8898 1.62155 13.9796C1.48908 14.2462 1.5436 14.5657 1.75579 14.7664C1.95884 14.9584 2.23582 15.003 2.50305 14.8868C2.59953 14.8449 2.8643 14.5828 8.36009 9.0896L14.1161 3.33629V7.78598C14.1161 10.7292 14.1216 12.2649 14.1323 12.3219C14.1819 12.5852 14.4093 12.8046 14.6761 12.8467C15.0449 12.9048 15.3918 12.6521 15.4446 12.2868C15.4668 12.1329 15.465 1.71239 15.4427 1.59173C15.3934 1.32528 15.1749 1.10672 14.9084 1.05746C14.7978 1.03703 4.33916 1.03603 4.19888 1.05645Z"
		fill="currentColor"
	/>
</svg> `;
var _a3;
var WalletList = (_a3 = class extends ScopedRegistryHost(LitElement) {
  constructor(..._args) {
    super(..._args);
    this.wallets = [];
  }
  render() {
    return this.wallets.length === 0 ? html`<div class="no-wallets-container">
					<div class="no-wallets-content">
						${downloadIcon}
						<h2 class="title">Install a wallet to get started on Sui</h2>
					</div>
					<internal-button class="wallet-cta" href="https://sui.io/get-started">
						Select a wallet to install ${arrowRightUpIcon}
					</internal-button>
				</div>` : html`<ul class="wallet-list">
					${this.wallets.map((wallet, index) => html`<wallet-list-item
								.wallet=${wallet}
								?autofocus=${index === 0}
							></wallet-list-item>`)}
				</ul>`;
  }
}, _a3.elementDefinitions = {
  "wallet-list-item": WalletListItem,
  "internal-button": Button
}, _a3.styles = styles$4, _a3);
__decorate([property({ type: Object })], WalletList.prototype, "wallets", void 0);
var _isOpen, _isOpening, _isConnected, _returnValue, _nextClickIsFromContent, _a4;
var BaseModal = (_a4 = class extends LitElement {
  constructor() {
    super(...arguments);
    __privateAdd(this, _isOpen, false);
    __privateAdd(this, _isOpening, false);
    __privateAdd(this, _isConnected, promiseWithResolvers());
    __privateAdd(this, _returnValue);
    __privateAdd(this, _nextClickIsFromContent, false);
  }
  /**
  * Opens the dialog when set to `true` and closes it when set to `false`.
  */
  get open() {
    return __privateGet(this, _isOpen);
  }
  set open(open) {
    if (open === __privateGet(this, _isOpen)) return;
    __privateSet(this, _isOpen, open);
    if (__privateGet(this, _isOpen)) {
      this.setAttribute("open", "");
      this.show();
    } else {
      this.removeAttribute("open");
      this.close();
    }
  }
  /**
  * Opens the dialog and fires a cancelable `open` event. An `opened` event
  * is fired after the dialog opens.
  *
  * @returns A `Promise` that resolves after the `opened` event was fired.
  */
  async show() {
    __privateSet(this, _isOpening, true);
    await __privateGet(this, _isConnected).promise;
    await this.updateComplete;
    if (this._dialog.open || !__privateGet(this, _isOpening)) {
      __privateSet(this, _isOpening, false);
      return;
    }
    if (!this.dispatchEvent(new Event("open", { cancelable: true }))) {
      this.open = false;
      __privateSet(this, _isOpening, false);
      return;
    }
    this._dialog.showModal();
    this.open = true;
    this.dispatchEvent(new Event("opened"));
    __privateSet(this, _isOpening, false);
  }
  /**
  * Closes the dialog and fires a cancelable `close` event. After a dialog's
  * animation, a `closed` event is fired.
  *
  * @param returnValue A return value usually indicating which button was used
  *     to close a dialog. If a dialog is canceled by clicking the backdrop or
  *     pressing Escape, it will not change the return value after closing.
  * @returns A Promise that resolves after the `closed` event was fired.
  */
  async close(returnValue = __privateGet(this, _returnValue)) {
    __privateSet(this, _isOpening, false);
    if (!this.isConnected) {
      this.open = false;
      return;
    }
    await this.updateComplete;
    if (!this._dialog.open || __privateGet(this, _isOpening)) {
      this.open = false;
      return;
    }
    const prevReturnValue = __privateGet(this, _returnValue);
    __privateSet(this, _returnValue, returnValue);
    if (!this.dispatchEvent(new Event("close", { cancelable: true }))) {
      __privateSet(this, _returnValue, prevReturnValue);
      return;
    }
    this._dialog.close(__privateGet(this, _returnValue));
    this.open = false;
    this.dispatchEvent(new Event("closed"));
  }
  connectedCallback() {
    super.connectedCallback();
    __privateGet(this, _isConnected).resolve();
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    __privateSet(this, _isConnected, Promise.withResolvers());
  }
  handleContentClick() {
    __privateSet(this, _nextClickIsFromContent, true);
  }
  handleDialogClick() {
    if (__privateGet(this, _nextClickIsFromContent)) {
      __privateSet(this, _nextClickIsFromContent, false);
      return;
    }
    if (!this.dispatchEvent(new Event("cancel", { cancelable: true }))) return;
    this.close();
  }
}, _isOpen = new WeakMap(), _isOpening = new WeakMap(), _isConnected = new WeakMap(), _returnValue = new WeakMap(), _nextClickIsFromContent = new WeakMap(), _a4.shadowRootOptions = {
  ...LitElement.shadowRootOptions,
  delegatesFocus: true
}, _a4);
__decorate([property({ type: Boolean })], BaseModal.prototype, "open", null);
__decorate([query("dialog")], BaseModal.prototype, "_dialog", void 0);
var closeIcon = html`<svg
	width="16"
	height="16"
	viewBox="0 0 16 16"
	fill="currentColor"
	xmlns="http://www.w3.org/2000/svg"
>
	<path
		fill-rule="evenodd"
		clip-rule="evenodd"
		d="M2.04841 1.59812C2.00001 1.61375 1.93695 1.63878 1.90828 1.65375C1.83709 1.69091 1.68775 1.84287 1.65047 1.91606C1.54047 2.13201 1.54381 2.37028 1.6597 2.57601C1.68564 2.62206 2.66404 3.61254 4.37417 5.32401L7.04809 8.00001L4.37417 10.676C2.67052 12.381 1.68551 13.3781 1.65959 13.424C1.49234 13.7201 1.56607 14.0843 1.83583 14.2945C2.04141 14.4547 2.34161 14.4734 2.57641 14.3408C2.62228 14.3149 3.61943 13.3299 5.32441 11.6262L8.00041 8.95233L10.6764 11.6262C12.3814 13.3299 13.3785 14.3149 13.4244 14.3408C13.6592 14.4734 13.9594 14.4547 14.165 14.2945C14.4347 14.0843 14.5085 13.7201 14.3412 13.424C14.3153 13.3781 13.3303 12.381 11.6266 10.676L8.95273 8.00001L11.6266 5.32401C13.3303 3.61903 14.3153 2.62188 14.3412 2.57601C14.4738 2.34121 14.4551 2.04102 14.2949 1.83543C14.0847 1.56567 13.7205 1.49195 13.4244 1.65919C13.3785 1.68511 12.3814 2.67012 10.6764 4.37377L8.00041 7.04769L5.32441 4.37377C3.61293 2.66364 2.62245 1.68524 2.57641 1.65931C2.41372 1.56766 2.21439 1.54457 2.04841 1.59812Z"
	/>
</svg> `;
var backIcon = html`<svg
	width="15"
	height="16"
	viewBox="0 0 15 16"
	fill="none"
	xmlns="http://www.w3.org/2000/svg"
>
	<path
		fill-rule="evenodd"
		clip-rule="evenodd"
		d="M6.90786 1.05824C6.70479 1.08877 6.91965 0.871204 3.62561 4.38197C0.943351 7.24072 0.593731 7.6189 0.554431 7.70397C0.501166 7.81932 0.480376 7.96424 0.497641 8.09997C0.525721 8.32084 0.315931 8.08477 3.59808 11.5887C5.25324 13.3557 6.6377 14.8229 6.67466 14.8493C6.76715 14.9153 6.88374 14.9481 7.01883 14.9464C7.19993 14.9441 7.32822 14.8862 7.45368 14.7503C7.6404 14.5479 7.68581 14.2362 7.56597 13.9793C7.53443 13.9117 7.06523 13.403 5.08008 11.2841L2.63307 8.67231L8.31776 8.66796C13.6185 8.66392 14.0073 8.6618 14.0739 8.63648C14.173 8.59888 14.3009 8.50512 14.3625 8.425C14.5276 8.21008 14.553 7.89213 14.4239 7.65714C14.3438 7.51138 14.1733 7.38224 14.013 7.34596C13.9549 7.33282 12.4096 7.32797 8.28312 7.32797H2.63276L5.07993 4.71597C7.0652 2.59698 7.53443 2.08824 7.56597 2.02063C7.68584 1.76365 7.6404 1.452 7.45358 1.24956C7.30854 1.09239 7.1201 1.02632 6.90786 1.05824Z"
		fill="currentColor"
	/>
</svg> `;
var styles$2 = [sharedStyles, css`
		:host {
			display: flex;
			flex-direction: column;
			align-items: center;
			text-align: center;
			flex-grow: 1;
			gap: 40px;
		}

		.logo {
			width: 120px;
			height: 120px;
			border-radius: var(--dapp-kit-radius-lg);
		}

		.container {
			display: flex;
			flex-direction: column;
			flex-grow: 1;
			gap: 12px;
		}

		.title {
			font-size: 24px;
			font-weight: var(--dapp-kit-font-weight-medium);
		}

		.copy {
			color: var(--dapp-kit-muted-foreground);
		}

		::slotted(*) {
			display: flex;
			flex-direction: column;
			width: 100%;
		}
	`];
var _a5;
var ConnectionStatus = (_a5 = class extends LitElement {
  constructor(..._args) {
    super(..._args);
    this.title = "";
    this.copy = "";
  }
  render() {
    return html`
			<img class="logo" src=${this.wallet.icon} alt=${`${this.wallet.name} logo`} />
			<div class="container">
				<h3 class="title">${this.title}</h3>
				<p class="copy">${this.copy}</p>
			</div>
			<slot name="call-to-action"></slot>
		`;
  }
}, _a5.styles = styles$2, _a5);
__decorate([property({ type: Object })], ConnectionStatus.prototype, "wallet", void 0);
__decorate([property({ type: String })], ConnectionStatus.prototype, "title", void 0);
__decorate([property({ type: String })], ConnectionStatus.prototype, "copy", void 0);
var styles$1 = [sharedStyles, css`
		dialog {
			width: 360px;
			height: 480px;
			border: 1px solid var(--dapp-kit-border);
			padding: 0;
			background: var(--dapp-kit-background);
			border-radius: var(--dapp-kit-radius-lg);
		}

		.content {
			display: flex;
			flex-direction: column;
			height: 100%;
			gap: 32px;
			padding: 24px;
		}

		.connect-header {
			display: flex;
			justify-content: space-between;
			align-items: center;
			gap: 8px;
		}

		.title {
			font-size: 18px;
			font-weight: var(--dapp-kit-font-weight-semibold);
			white-space: nowrap;
		}

		.close-button {
			margin-left: auto;
		}

		.cancel-button {
			margin-top: auto;
		}
	`];
var iconButtonStyles = css`
	.icon-button {
		width: 32px;
		height: 32px;
		border-radius: 50%;
		background: inherit;
		color: var(--dapp-kit-foreground);
		display: inline-flex;
		align-items: center;
		justify-content: center;
		transition:
			background-color 200ms,
			transform 100ms;
	}

	.icon-button:hover {
		background-color: var(--dapp-kit-accent);
	}

	.icon-button:active {
		transform: scale(0.9);
	}
`;
var _abortController, _DAppKitConnectModal$1_instances, renderModalView_fn, attemptConnect_fn, resetSelection_fn, getWallets_fn, _a6;
var DAppKitConnectModal = (_a6 = class extends ScopedRegistryHost(BaseModal) {
  constructor(..._args) {
    super(..._args);
    __privateAdd(this, _DAppKitConnectModal$1_instances);
    __privateAdd(this, _abortController);
    this._state = { view: "wallet-selection" };
  }
  render() {
    const showBackButton = this._state.view === "connecting" || this._state.view === "error";
    const wallets = __privateMethod(this, _DAppKitConnectModal$1_instances, getWallets_fn).call(this);
    return html`<dialog @click=${this.handleDialogClick} @close=${__privateMethod(this, _DAppKitConnectModal$1_instances, resetSelection_fn)}>
			<div class="content" @click=${this.handleContentClick}>
				<div class="connect-header">
					${showBackButton ? html`<button
								class="icon-button back-button"
								aria-label="Go back"
								@click=${__privateMethod(this, _DAppKitConnectModal$1_instances, resetSelection_fn)}
							>
								${backIcon}
							</button>` : nothing}
					<h2 class="title">${wallets.length > 0 ? "Connect a wallet" : "No wallets installed"}</h2>
					<button
						class="icon-button close-button"
						aria-label="Close"
						@click=${() => {
      this.close("cancel");
    }}
					>
						${closeIcon}
					</button>
				</div>
				${__privateMethod(this, _DAppKitConnectModal$1_instances, renderModalView_fn).call(this, wallets)}
			</div>
		</dialog>`;
  }
}, _abortController = new WeakMap(), _DAppKitConnectModal$1_instances = new WeakSet(), renderModalView_fn = function(wallets) {
  switch (this._state.view) {
    case "wallet-selection":
      return html`<wallet-list
					.wallets=${wallets}
					@wallet-selected=${async (event) => {
        __privateMethod(this, _DAppKitConnectModal$1_instances, attemptConnect_fn).call(this, event.detail.wallet);
      }}
				></wallet-list>`;
    case "connecting":
      return html`<connection-status
					.title=${"Awaiting connection..."}
					.copy=${`Accept the request from ${this._state.wallet.name} in order to proceed`}
					.wallet=${this._state.wallet}
				>
					<internal-button
						slot="call-to-action"
						.variant=${"secondary"}
						@click=${__privateMethod(this, _DAppKitConnectModal$1_instances, resetSelection_fn)}
					>
						Cancel
					</internal-button>
				</connection-status>`;
    case "error":
      const { wallet, error } = this._state;
      const wasRequestCancelled = isWalletStandardError(error, WALLET_STANDARD_ERROR__USER__REQUEST_REJECTED);
      return html`<connection-status
					.title=${wasRequestCancelled ? "Request canceled" : "Connection failed"}
					.copy=${wasRequestCancelled ? `You canceled the request` : "Something went wrong. Please try again"}
					.wallet=${wallet}
				>
					<internal-button
						slot="call-to-action"
						@click=${() => {
        __privateMethod(this, _DAppKitConnectModal$1_instances, attemptConnect_fn).call(this, wallet);
      }}
					>
						Retry
					</internal-button>
				</connection-status>`;
    default:
      throw new Error(`Encountered unknown view state: ${this._state}`);
  }
}, attemptConnect_fn = async function(wallet) {
  let delayTimeout;
  try {
    const abortPromise = new Promise((_, reject) => {
      __privateSet(this, _abortController, new AbortController());
      __privateGet(this, _abortController).signal.addEventListener("abort", () => reject(new DOMException("Aborted", "AbortError")), { once: true });
    });
    delayTimeout = setTimeout(() => {
      this._state = {
        view: "connecting",
        wallet
      };
    }, 100);
    await Promise.race([abortPromise, this.instance.connectWallet({ wallet })]);
    this.close("successful-connection");
  } catch (error) {
    if (error instanceof Error && error.name === "AbortError") this._state = { view: "wallet-selection" };
    else this._state = {
      view: "error",
      wallet,
      error
    };
  } finally {
    clearTimeout(delayTimeout);
  }
}, resetSelection_fn = function() {
  if (this._state.view === "connecting") __privateGet(this, _abortController)?.abort("cancelled");
  else this._state = { view: "wallet-selection" };
}, getWallets_fn = function() {
  const wallets = this.instance.stores.$wallets.get();
  const filtered = this.filterFn ? wallets.filter(this.filterFn) : wallets;
  return this.sortFn ? filtered.toSorted(this.sortFn) : filtered;
}, _a6.styles = [styles$1, iconButtonStyles], _a6.elementDefinitions = {
  "wallet-list": WalletList,
  "internal-button": Button,
  "connection-status": ConnectionStatus
}, _a6);
__decorate([storeProperty()], DAppKitConnectModal.prototype, "instance", void 0);
__decorate([state()], DAppKitConnectModal.prototype, "_state", void 0);
__decorate([property({ attribute: false })], DAppKitConnectModal.prototype, "filterFn", void 0);
__decorate([property({ attribute: false })], DAppKitConnectModal.prototype, "sortFn", void 0);
DAppKitConnectModal = __decorate([customElement("mysten-dapp-kit-connect-modal")], DAppKitConnectModal);
var unlinkIcon = html`<svg
	width="17"
	height="16"
	viewBox="0 0 17 16"
	fill="currentColor"
	xmlns="http://www.w3.org/2000/svg"
>
	<path
		fill-rule="evenodd"
		clip-rule="evenodd"
		d="M11.22 0.538749C10.6265 0.598285 10.1912 0.722509 9.66001 0.983949C9.37775 1.12286 9.12319 1.28297 8.87601 1.47704C8.69228 1.62129 6.93319 3.37158 6.85697 3.48597C6.78033 3.60101 6.75383 3.69451 6.75437 3.84801C6.75508 4.04564 6.81122 4.18171 6.94887 4.31936C7.14239 4.51288 7.43207 4.56667 7.68401 4.45585C7.78109 4.41317 7.84866 4.34988 8.70001 3.50432C9.20161 3.00612 9.65881 2.56196 9.71601 2.51731C10.0519 2.25499 10.4706 2.05141 10.892 1.94537C11.2092 1.86557 11.7213 1.84326 12.0514 1.89489C12.9243 2.03139 13.651 2.49584 14.1437 3.23201C14.3077 3.47704 14.4669 3.8423 14.5477 4.15877C14.6587 4.59373 14.6616 5.18297 14.5546 5.60801C14.4471 6.03561 14.2443 6.45003 13.9762 6.79022C13.9268 6.85281 13.489 7.30361 13.0031 7.79201C12.5173 8.28041 12.1015 8.7095 12.0793 8.74557C12.0217 8.83864 11.988 8.96494 11.9882 9.08693C11.9885 9.27032 12.0513 9.42179 12.1808 9.55125C12.3159 9.68635 12.4532 9.74419 12.644 9.74638C12.7905 9.74808 12.9047 9.71592 13.016 9.64171C13.1301 9.56558 14.864 7.82219 15.0147 7.63201C15.502 7.01705 15.8117 6.30936 15.9321 5.53601C15.9672 5.31038 15.9813 4.73297 15.9576 4.48801C15.9054 3.94678 15.7771 3.48822 15.5414 3.00001C15.3126 2.52614 15.0685 2.18312 14.6927 1.80733C13.9789 1.09355 13.1035 0.668781 12.1059 0.552077C11.9206 0.530397 11.3837 0.522333 11.22 0.538749ZM5.2445 1.05827C5.0433 1.08664 4.84421 1.23966 4.75012 1.43825L4.70001 1.54401L4.69549 2.46219C4.69154 3.26985 4.69412 3.39117 4.71692 3.47019C4.76266 3.62872 4.85655 3.75208 5.00476 3.84838C5.20802 3.98045 5.48217 3.98582 5.69402 3.8619C5.77233 3.81611 5.90889 3.67566 5.94727 3.60145C6.01841 3.46387 6.01965 3.44486 6.01983 2.49262C6.02001 1.61425 6.01895 1.58238 5.98692 1.49678C5.87002 1.18435 5.57716 1.01137 5.2445 1.05827ZM2.59673 1.58549C2.4178 1.62057 2.22357 1.77176 2.14122 1.94009C2.08143 2.06232 2.05881 2.21302 2.08055 2.34425C2.11277 2.53877 2.15631 2.60016 2.52401 2.96969C2.81721 3.26435 2.87423 3.31429 2.97162 3.36169C3.07791 3.41342 3.09167 3.41601 3.25962 3.41601C3.4238 3.41601 3.44327 3.41257 3.541 3.36627C3.67756 3.30155 3.80154 3.17757 3.86626 3.04101C3.91257 2.94328 3.91601 2.9238 3.91601 2.75963C3.91601 2.59168 3.91341 2.57792 3.86169 2.47163C3.81428 2.37424 3.76434 2.31721 3.46969 2.02401C3.10991 1.66603 3.04322 1.61725 2.86836 1.58408C2.77031 1.56549 2.69684 1.56587 2.59673 1.58549ZM2.02801 4.21445C1.85482 4.26936 1.69453 4.40416 1.61634 4.56062C1.53162 4.73012 1.5306 4.97821 1.61388 5.14899C1.67375 5.27179 1.8045 5.39857 1.93497 5.46037L2.04401 5.51201L2.96401 5.51667C3.92485 5.52155 3.95385 5.51987 4.09084 5.45173C4.17271 5.41101 4.31301 5.27763 4.36189 5.19403C4.57817 4.82427 4.38473 4.33845 3.97309 4.21753C3.89789 4.19545 3.76553 4.19216 2.98909 4.19309C2.31132 4.19389 2.07636 4.19912 2.02801 4.21445ZM10.4794 5.24865C10.4373 5.25573 10.3545 5.28401 10.2954 5.3115C10.1935 5.35891 10.0767 5.47275 8.02474 7.52475C5.98373 9.56576 5.85868 9.694 5.81218 9.794C5.68556 10.0662 5.73263 10.3648 5.93393 10.5661C6.13521 10.7674 6.4338 10.8145 6.70602 10.6878C6.80602 10.6413 6.93426 10.5163 8.97527 8.47528C11.0163 6.43427 11.1413 6.30603 11.1878 6.20603C11.2829 6.00173 11.2838 5.80633 11.1907 5.61C11.1022 5.42347 10.9104 5.28238 10.6982 5.24763C10.5933 5.23045 10.5875 5.23048 10.4794 5.24865ZM4.25201 6.25709C4.13005 6.27627 4.07709 6.29624 3.98469 6.35787C3.87025 6.43421 2.13679 8.17691 1.98524 8.36801C1.7866 8.61848 1.62597 8.87236 1.48417 9.16001C1.25775 9.61931 1.14644 9.96928 1.0669 10.472C1.03255 10.6891 1.01855 11.2894 1.04242 11.5218C1.13201 12.3938 1.44233 13.1559 1.99106 13.8515C2.11753 14.0118 2.48823 14.3825 2.64853 14.509C3.34417 15.0577 4.10626 15.368 4.9782 15.4576C5.21338 15.4818 5.80996 15.4674 6.03601 15.4322C6.811 15.3113 7.51625 15.0026 8.13201 14.5147C8.32218 14.364 10.0656 12.6301 10.1417 12.516C10.2159 12.4047 10.2481 12.2905 10.2464 12.144C10.2442 11.9532 10.1863 11.8159 10.0512 11.6808C9.92178 11.5513 9.77031 11.4885 9.58692 11.4882C9.46493 11.488 9.33863 11.5217 9.24556 11.5793C9.20949 11.6015 8.78041 12.0173 8.29201 12.5031C7.80361 12.989 7.35281 13.4268 7.29021 13.4762C6.95002 13.7443 6.53561 13.9471 6.10801 14.0547C5.68297 14.1616 5.09372 14.1587 4.65876 14.0477C4.1114 13.9079 3.64604 13.6439 3.25109 13.2489C2.7846 12.7824 2.49877 12.2158 2.39489 11.5514C2.35978 11.3269 2.35981 10.8808 2.39497 10.656C2.47809 10.1242 2.69338 9.62913 3.02385 9.20981C3.07317 9.14721 3.51778 8.68921 4.01186 8.19201C4.85073 7.34785 4.91322 7.28113 4.95589 7.18401C5.06609 6.93325 5.01277 6.6423 4.82162 6.45115C4.66466 6.29419 4.45981 6.2244 4.25201 6.25709ZM13.548 10.5024C13.3666 10.56 13.2147 10.6922 13.1337 10.863C13.0874 10.9607 13.084 10.9802 13.084 11.1444C13.084 11.3106 13.0869 11.3268 13.1354 11.4252C13.2206 11.5981 13.3733 11.7304 13.5493 11.7838C13.6613 11.8178 14.8548 11.819 14.9659 11.7852C15.1861 11.7184 15.3611 11.5473 15.4232 11.3381C15.455 11.2312 15.4542 11.0513 15.4215 10.9388C15.3698 10.7611 15.1977 10.5858 15.0032 10.5131C14.919 10.4816 14.8842 10.4801 14.2634 10.4811C13.7842 10.4819 13.5951 10.4875 13.548 10.5024ZM11.4431 12.5983C11.2533 12.6712 11.1165 12.7929 11.0377 12.959L10.988 13.064L10.9834 13.7377C10.9789 14.3897 10.9798 14.4143 11.0124 14.5015C11.0858 14.6977 11.2604 14.8696 11.4388 14.9215C11.8061 15.0283 12.1748 14.8298 12.2852 14.4659C12.319 14.3548 12.3177 13.1613 12.2838 13.0494C12.2305 12.8735 12.0981 12.7206 11.9257 12.6357C11.8326 12.5899 11.8052 12.5842 11.6609 12.5806C11.5544 12.5779 11.4808 12.5839 11.4431 12.5983ZM13.5391 12.5983C13.3493 12.6712 13.2125 12.7929 13.1337 12.959C13.0874 13.0567 13.084 13.0762 13.084 13.2404C13.084 13.4083 13.0866 13.4221 13.1383 13.5284C13.1857 13.6258 13.2357 13.6828 13.5303 13.976C13.9023 14.3462 13.9559 14.3839 14.1582 14.4172C14.3748 14.453 14.5719 14.3886 14.7303 14.2303C14.8886 14.0719 14.953 13.8748 14.9172 13.6582C14.8838 13.4559 14.8462 13.4023 14.476 13.0303C14.1833 12.7362 14.1257 12.6857 14.0289 12.6386C13.9283 12.5896 13.9028 12.5842 13.7569 12.5806C13.6504 12.5779 13.5768 12.5839 13.5391 12.5983Z"
	/>
</svg>`;
var styles = [
  sharedStyles,
  iconButtonStyles,
  css`
		:host {
			display: block;
			width: fit-content;
		}

		.menu {
			display: none;
		}

		[aria-expanded='true'] + .menu {
			display: flex;
			flex-direction: column;
			max-width: fit-content;
			min-width: 396px;
			gap: 16px;
			padding: 16px;
			position: absolute;
			outline: none;
			background-color: var(--dapp-kit-popover);
			color: var(--dapp-kit-popover-foreground);
			border-radius: var(--dapp-kit-radius-lg);
			border: 1px solid var(--dapp-kit-border);
			box-shadow:
				0 4px 6px -1px rgba(0, 0, 0, 0.1),
				0 2px 4px -2px rgba(0, 0, 0, 0.1);
		}

		.header-container {
			display: flex;
			align-items: center;
			justify-content: space-between;
		}

		.header-title {
			font-size: 18px;
			font-weight: var(--dapp-kit-font-weight-semibold);
			letter-spacing: -0.18px;
		}

		img {
			width: 24px;
			height: 24px;
			border-radius: 96px;
		}

		[aria-expanded='true'] .chevron {
			transition: transform 0.3s ease;
			transform: rotate(180deg);
		}

		.chevron {
			display: flex;
		}

		.chevron svg {
			width: 12px;
			height: 12px;
		}

		.trigger-content {
			display: flex;
			align-items: center;
			font-weight: var(--dapp-kit-font-weight-semibold);
			gap: 12px;
		}

		.accounts-list {
			display: flex;
			flex-direction: column;
			gap: 12px;
			max-height: 240px;
			overflow-y: auto;
		}

		.disconnect-button {
			background-color: rgba(0, 0, 0, 0.8);
			display: inline-flex;
			align-items: center;
			justify-content: center;
			width: 100%;
			background-color: var(--dapp-kit-secondary);
			color: var(--dapp-kit-destructive);
			border-radius: var(--dapp-kit-radius-md);
			font-weight: var(--dapp-kit-font-weight-medium);
			height: 48px;
			padding: 16px;
			gap: 8px;
		}

		.disconnect-button:hover {
			background-color: color-mix(in oklab, var(--dapp-kit-secondary) 80%, transparent);
		}

		.container {
			padding-top: 12px;
			padding-bottom: 12px;
			padding-left: 16px;
			padding-right: 16px;
			display: flex;
			align-items: center;
			justify-content: space-between;
			gap: 8px;
			width: 100%;
			border-radius: var(--dapp-kit-radius-sm);
		}

		.container[data-checked='true'] {
			background-color: var(--dapp-kit-accent);
		}

		.account-title {
			font-weight: var(--dapp-kit-font-weight-semibold);
		}

		.account-subtitle {
			color: var(--dapp-kit-muted-foreground);
			font-weight: var(--dapp-kit-font-weight-medium);
			font-size: 14px;
		}

		.account-info {
			display: flex;
			flex-direction: column;
			gap: 4px;
		}

		.content {
			display: flex;
			flex-grow: 1;
			gap: 12px;
		}

		.copy-address-button {
			display: inline-flex;
		}

		.copy-address-button svg {
			width: 16px;
			height: 16px;
		}

		.radio-indicator {
			width: 20px;
			height: 20px;
			border-radius: 100%;
			background-color: var(--dapp-kit-input);
			border: 1px solid var(--dapp-kit-border);
			display: inline-flex;
			justify-content: center;
			align-items: center;
		}

		.content:focus-visible .radio-indicator {
			border-color: var(--dapp-kit-ring);
			box-shadow: 0 0 0 3px var(--dapp-kit-ring) / 0.5;
			outline: none;
		}

		[data-checked='true'] .radio-indicator {
			color: var(--dapp-kit-positive);
			border-color: var(--dapp-kit-positive);
		}

		.radio-input {
			appearance: none;
			-webkit-appearance: none;
			width: 20px;
			height: 20px;
			margin: 0;
			border-radius: 50%;
			background-color: var(--dapp-kit-input);
			border: 1px solid var(--dapp-kit-input);
			cursor: pointer;
			position: relative;
			outline: none;
			transition: box-shadow 0.2s;
		}

		.radio-input::before {
			content: '';
			position: absolute;
			top: 50%;
			left: 50%;
			width: 8px;
			height: 8px;
			background-color: var(--dapp-kit-positive);
			border-radius: 100%;
			transform: translate(-50%, -50%) scale(0);
			transition: transform 0.2s ease;
		}

		.radio-input:checked {
			background-color: transparent;
			border-color: var(--dapp-kit-positive);
		}

		.radio-input:checked::before {
			transform: translate(-50%, -50%) scale(1);
		}

		.radio-input:focus-visible {
			border-color: var(--dapp-kit-ring);
			box-shadow: 0 0 0 3px var(--dapp-kit-ring);
		}
	`
];
var copyIcon = html`<svg
	width="16"
	height="16"
	viewBox="0 0 16 16"
	fill="currentColor"
	xmlns="http://www.w3.org/2000/svg"
>
	<path
		fill-rule="evenodd"
		clip-rule="evenodd"
		d="M2.57602 1.05841C1.96473 1.12213 1.42869 1.52667 1.18005 2.11198C1.1061 2.28603 1.0777 2.39982 1.05682 2.60568C1.03369 2.83379 1.03361 9.476 1.05673 9.71992C1.12471 10.4367 1.60071 11.0082 2.31202 11.227L2.45602 11.2713L3.58402 11.2796L4.71202 11.288L4.72098 12.416C4.7307 13.6405 4.7262 13.5765 4.82061 13.8331C4.95698 14.2037 5.26674 14.5566 5.62014 14.7439C5.85567 14.8688 6.02999 14.9204 6.29721 14.9443C6.5825 14.9699 13.4137 14.9564 13.544 14.9301C14.2457 14.7881 14.7885 14.2454 14.9301 13.544C14.9564 13.4135 14.9699 6.582 14.9444 6.29717C14.9204 6.02992 14.8688 5.8556 14.744 5.62009C14.5566 5.2667 14.2038 4.95694 13.8332 4.82057C13.5766 4.72616 13.6405 4.73065 12.416 4.72094L11.288 4.71198L11.2797 3.58398L11.2713 2.45598L11.227 2.31198C11.1329 2.00597 10.9791 1.74963 10.7655 1.54273C10.4634 1.25013 10.1311 1.09568 9.71996 1.05669C9.50114 1.03595 2.77607 1.03757 2.57602 1.05841ZM2.64002 2.40489C2.56149 2.42965 2.42756 2.56833 2.40348 2.64984C2.38845 2.70067 2.3841 3.50549 2.38437 6.17784C2.38473 9.62633 2.38485 9.64027 2.41732 9.71198C2.45749 9.80075 2.51625 9.86424 2.60002 9.90945C2.66343 9.94366 2.67351 9.94403 3.69159 9.94843L4.71916 9.95288L4.72359 8.03643L4.72802 6.11998L4.77265 5.97758C4.96105 5.37641 5.37855 4.9584 5.97602 4.77273L6.12002 4.72798L8.03647 4.72355L9.95292 4.71912L9.94847 3.69155C9.94407 2.67347 9.9437 2.66339 9.9095 2.59998C9.86428 2.51621 9.80079 2.45745 9.71202 2.41728C9.64026 2.3848 9.62818 2.38469 6.16802 2.38597C3.68466 2.38688 2.68007 2.39227 2.64002 2.40489ZM6.33593 6.06286C6.22594 6.09651 6.14185 6.16683 6.08585 6.27198C6.05701 6.32613 6.05602 6.44379 6.05602 9.83198V13.336L6.09108 13.4015C6.1358 13.4851 6.21761 13.5568 6.30634 13.5904C6.37039 13.6146 6.65799 13.6164 9.86402 13.6124C13.1284 13.6083 13.3553 13.6062 13.4023 13.5804C13.4667 13.5452 13.5453 13.4666 13.5805 13.4023C13.6063 13.3552 13.6083 13.1283 13.6124 9.86398C13.6164 6.65795 13.6146 6.37035 13.5904 6.3063C13.5569 6.21757 13.4851 6.13576 13.4015 6.09104L13.336 6.05598L9.85602 6.05328C7.94202 6.05181 6.35798 6.05611 6.33593 6.06286Z"
	/>
</svg> `;
var cache = /* @__PURE__ */ new Map();
async function resolveNameServiceName(client, address) {
  if (cache.has(address)) return cache.get(address);
  try {
    const name = (await client.core.defaultNameServiceName?.({ address }))?.data.name;
    cache.set(address, name ? normalizeSuiNSName(name, "at") : null);
    return name;
  } catch {
    cache.set(address, null);
    return null;
  }
}
var circleCheckIcon = html`<svg
	xmlns="http://www.w3.org/2000/svg"
	width="24"
	height="24"
	viewBox="0 0 24 24"
	fill="none"
	stroke="var(--dapp-kit-positive)"
	stroke-width="2"
	stroke-linecap="round"
	stroke-linejoin="round"
>
	<circle cx="12" cy="12" r="10" />
	<path d="m9 12 2 2 4-4" />
</svg> `;
var AccountMenuItem = class extends LitElement {
  constructor(..._args) {
    super(..._args);
    this.selected = false;
    this._wasCopySuccessful = false;
  }
  createRenderRoot() {
    return this;
  }
  #resolveNameTask = new Task(this, {
    args: () => [this.client, this.account.address],
    task: async ([client, address]) => resolveNameServiceName(client, address)
  });
  connectedCallback() {
    super.connectedCallback();
    this.addEventListener("click", this.#accountSelected);
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.removeEventListener("click", this.#accountSelected);
  }
  render() {
    return html`
			<div class="container" data-checked=${this.selected}>
				<input
					type="radio"
					name="wallet-address"
					tabindex="${this.selected ? "0" : "-1"}"
					value=${this.account.address}
					?checked=${this.selected}
					@change=${this.#accountSelected}
					class="radio-input"
					id=${this.account.address}
				/>
				<label class="content" for=${this.account.address}>
					${when(this.account.icon, (icon) => html`<img src=${icon} alt="" />`)}
					${this.#resolveNameTask.render({
      pending: this.#renderAccountInfo,
      complete: this.#renderAccountInfo,
      error: () => this.#renderAccountInfo()
    })}
				</label>
				<button
					class="copy-address-button"
					@click=${this.#copyAddressToClipboard}
					aria-label="Copy address"
				>
					${this._wasCopySuccessful ? circleCheckIcon : copyIcon}
				</button>
			</div>
		`;
  }
  async #copyAddressToClipboard(event) {
    event.stopPropagation();
    try {
      await navigator.clipboard.writeText(this.account.address);
      this._wasCopySuccessful = true;
      setTimeout(() => {
        this._wasCopySuccessful = false;
      }, 2e3);
    } catch {
    }
  }
  #renderAccountInfo = (name) => {
    const { address, label } = this.account;
    const formattedAddress = formatAddress(address);
    const title = name || label;
    return html`<div class="account-info">
			<div class="account-title">${title || formattedAddress}</div>
			${when(title, () => html`<div class="account-subtitle">${formattedAddress}</div>`)}
		</div>`;
  };
  #accountSelected() {
    this.dispatchEvent(new CustomEvent("account-selected", {
      detail: { account: this.account },
      bubbles: true,
      composed: true
    }));
  }
};
__decorate([property({ type: Object })], AccountMenuItem.prototype, "account", void 0);
__decorate([property({ type: Object })], AccountMenuItem.prototype, "client", void 0);
__decorate([property({ type: Boolean })], AccountMenuItem.prototype, "selected", void 0);
__decorate([state()], AccountMenuItem.prototype, "_wasCopySuccessful", void 0);
var chevronDownIcon = html`<svg
	width="12"
	height="12"
	viewBox="0 0 12 12"
	fill="currentColor"
	xmlns="http://www.w3.org/2000/svg"
>
	<path
		fill-rule="evenodd"
		clip-rule="evenodd"
		d="M0.749783 3.16083C0.616367 3.20313 0.499715 3.30493 0.439031 3.432C0.404351 3.50463 0.401783 3.5191 0.401783 3.642C0.401783 3.8842 0.122795 3.58063 2.91474 6.3763C4.25842 7.72175 5.39718 8.85432 5.44534 8.8931C5.61112 9.02664 5.77771 9.084 5.99978 9.084C6.22186 9.084 6.38845 9.02664 6.55423 8.8931C6.60239 8.85432 7.74115 7.72175 9.08483 6.3763C11.8768 3.58063 11.5978 3.8842 11.5978 3.642C11.5978 3.5191 11.5952 3.50463 11.5605 3.432C11.512 3.33045 11.4169 3.23542 11.3163 3.18797C11.2247 3.14475 11.0777 3.13074 10.9826 3.15618C10.8399 3.19439 10.9127 3.12454 8.39678 5.63854L5.99978 8.03374L3.60278 5.6387C1.98712 4.02436 1.18712 3.23308 1.14854 3.21119C1.11707 3.19332 1.06577 3.17095 1.03454 3.16149C0.965327 3.14049 0.815051 3.14014 0.749783 3.16083Z"
	/>
</svg>`;
var plusIcon = html`<svg
	width="16"
	height="16"
	viewBox="0 0 16 16"
	fill="currentColor"
	xmlns="http://www.w3.org/2000/svg"
>
	<path
		fill-rule="evenodd"
		clip-rule="evenodd"
		d="M7.89082 1.05657C7.62439 1.0948 7.38895 1.33323 7.34347 1.61086C7.33421 1.66737 7.32818 2.80358 7.32813 4.49999L7.32803 7.296H4.4625C1.27722 7.296 1.51488 7.28764 1.34404 7.40553C1.22967 7.48444 1.11213 7.63921 1.07837 7.75534C1.04733 7.86214 1.04613 8.06073 1.07597 8.15199C1.1289 8.3138 1.2622 8.47769 1.39693 8.54657C1.55365 8.62668 1.43055 8.6236 4.47604 8.6238L7.32803 8.62399L7.32813 11.46C7.32818 13.2384 7.33408 14.3318 7.34392 14.392C7.38999 14.6737 7.62421 14.9044 7.90416 14.944C8.26109 14.9945 8.59807 14.7471 8.65615 14.392C8.66599 14.3318 8.67189 13.2384 8.67194 11.46L8.67203 8.62399L11.524 8.6238C14.5695 8.6236 14.4464 8.62668 14.6031 8.54657C14.7379 8.47769 14.8712 8.3138 14.9241 8.15199C14.9539 8.06073 14.9527 7.86214 14.9217 7.75534C14.8879 7.63921 14.7704 7.48444 14.656 7.40553C14.4852 7.28764 14.7229 7.296 11.5376 7.296H8.67203L8.67194 4.49999C8.67189 2.80358 8.66586 1.66737 8.65659 1.61086C8.6172 1.37032 8.44339 1.16228 8.21551 1.08292C8.12912 1.05284 7.99355 1.04184 7.89082 1.05657Z"
	/>
</svg>`;
var _unsubscribeFromAutoUpdate, _resolveNameTask, __this_instances2, onDisconnectClick_fn, onManageConnectionClick_fn, _getAccountTitle, _onDocumentClick, toggleMenu_fn, openMenu_fn, closeMenu_fn, startPositioning_fn, stopPositioning_fn, _a7;
var ConnectedAccountMenu = (_a7 = class extends ScopedRegistryHost(LitElement) {
  constructor(..._args) {
    super(..._args);
    __privateAdd(this, __this_instances2);
    __privateAdd(this, _unsubscribeFromAutoUpdate);
    __privateAdd(this, _resolveNameTask, new Task(this, {
      args: () => [this.client, this.connection.account.address],
      task: async ([client, address]) => resolveNameServiceName(client, address)
    }));
    __privateAdd(this, _getAccountTitle, (name) => {
      return name || this.connection.account.label || formatAddress(this.connection.account.address);
    });
    __privateAdd(this, _onDocumentClick, (event) => {
      if (!this._open) return;
      if (!event.composedPath().includes(this)) __privateMethod(this, __this_instances2, closeMenu_fn).call(this);
    });
    this._open = false;
  }
  connectedCallback() {
    super.connectedCallback();
    document.addEventListener("click", __privateGet(this, _onDocumentClick));
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    __privateMethod(this, __this_instances2, stopPositioning_fn).call(this);
    document.removeEventListener("click", __privateGet(this, _onDocumentClick));
  }
  render() {
    return html`<internal-button
				id="menu-button"
				aria-haspopup="true"
				aria-controls="menu"
				aria-expanded="${this._open}"
				@click=${__privateMethod(this, __this_instances2, toggleMenu_fn)}
			>
				<div class="trigger-content">
					<img src=${this.connection.account.icon ?? this.connection.wallet.icon} alt="" />
					${__privateGet(this, _resolveNameTask).render({
      pending: __privateGet(this, _getAccountTitle),
      complete: __privateGet(this, _getAccountTitle),
      error: () => __privateGet(this, _getAccountTitle)
    })}
					<div class="chevron">${chevronDownIcon}</div>
				</div>
			</internal-button>
			<div class="menu" id="menu" tabindex="-1" aria-labelledby="menu-button">
				<div class="header-container">
					<h2 class="header-title">Connected accounts</h2>
					${when(this.connection.wallet.name.startsWith(SLUSH_WALLET_NAME), () => html`<button
								class="icon-button"
								aria-label="Add more accounts"
								@click=${__privateMethod(this, __this_instances2, onManageConnectionClick_fn)}
							>
								${plusIcon}
							</button>`)}
				</div>
				<div class="accounts-container" role="radiogroup">
					<ul class="accounts-list">
						${this.connection.wallet.accounts.map((account) => html`
								<li>
									<account-menu-item
										.account=${account}
										.client=${this.client}
										.selected=${account.address === this.connection.account.address}
									></account-menu-item>
								</li>
							`)}
					</ul>
				</div>
				<button class="disconnect-button" @click=${__privateMethod(this, __this_instances2, onDisconnectClick_fn)}>
					${unlinkIcon} Disconnect all
				</button>
			</div>`;
  }
}, _unsubscribeFromAutoUpdate = new WeakMap(), _resolveNameTask = new WeakMap(), __this_instances2 = new WeakSet(), onDisconnectClick_fn = function() {
  this.dispatchEvent(new CustomEvent("disconnect-click", {
    bubbles: true,
    composed: true
  }));
}, onManageConnectionClick_fn = function() {
  this.dispatchEvent(new CustomEvent("manage-connection-click", {
    bubbles: true,
    composed: true
  }));
}, _getAccountTitle = new WeakMap(), _onDocumentClick = new WeakMap(), toggleMenu_fn = function() {
  if (this._open) __privateMethod(this, __this_instances2, closeMenu_fn).call(this);
  else __privateMethod(this, __this_instances2, openMenu_fn).call(this);
}, openMenu_fn = async function() {
  this._open = true;
  await this.updateComplete;
  this._menu.focus();
  __privateMethod(this, __this_instances2, startPositioning_fn).call(this);
}, closeMenu_fn = function() {
  this._open = false;
  __privateMethod(this, __this_instances2, stopPositioning_fn).call(this);
}, startPositioning_fn = function() {
  __privateSet(this, _unsubscribeFromAutoUpdate, autoUpdate(this._trigger, this._menu, async () => {
    const result = await computePosition(this._trigger, this._menu, {
      placement: "bottom-end",
      middleware: [
        offset(12),
        flip(),
        shift({ padding: 16 }),
        autoPlacement()
      ]
    });
    Object.assign(this._menu.style, {
      left: `${result.x}px`,
      top: `${result.y}px`
    });
  }));
}, stopPositioning_fn = function() {
  if (__privateGet(this, _unsubscribeFromAutoUpdate)) {
    __privateGet(this, _unsubscribeFromAutoUpdate).call(this);
    __privateSet(this, _unsubscribeFromAutoUpdate, void 0);
  }
}, _a7.elementDefinitions = {
  "internal-button": Button,
  "account-menu-item": AccountMenuItem
}, _a7.styles = styles, _a7);
__decorate([property({ type: Object })], ConnectedAccountMenu.prototype, "connection", void 0);
__decorate([property({ type: Object })], ConnectedAccountMenu.prototype, "client", void 0);
__decorate([query("#menu-button")], ConnectedAccountMenu.prototype, "_trigger", void 0);
__decorate([query("#menu")], ConnectedAccountMenu.prototype, "_menu", void 0);
__decorate([state()], ConnectedAccountMenu.prototype, "_open", void 0);
var _DAppKitConnectButton$1_instances, openModal_fn, _a8;
var DAppKitConnectButton = (_a8 = class extends ScopedRegistryHost(LitElement) {
  constructor() {
    super(...arguments);
    __privateAdd(this, _DAppKitConnectButton$1_instances);
  }
  render() {
    const connection = this.instance.stores.$connection.get();
    const client = this.instance.stores.$currentClient.get();
    return connection.account ? html`<connected-account-menu
					.connection=${connection}
					.client=${client}
					@account-selected=${(event) => {
      this.instance.switchAccount({ account: event.detail.account });
    }}
					@disconnect-click=${() => {
      this.instance.disconnectWallet();
    }}
					@manage-connection-click=${() => {
      this.instance.connectWallet({ wallet: connection.wallet });
    }}
				></connected-account-menu>` : html`<internal-button @click=${__privateMethod(this, _DAppKitConnectButton$1_instances, openModal_fn)}>
						<slot>Connect Wallet</slot>
					</internal-button>
					<mysten-dapp-kit-connect-modal
						.instance=${this.instance}
						.filterFn=${this.modalOptions?.filterFn}
						.sortFn=${this.modalOptions?.sortFn}
					></mysten-dapp-kit-connect-modal>`;
  }
}, _DAppKitConnectButton$1_instances = new WeakSet(), openModal_fn = function() {
  this._modal.show();
}, _a8.elementDefinitions = {
  "internal-button": Button,
  "mysten-dapp-kit-connect-modal": DAppKitConnectModal,
  "connected-account-menu": ConnectedAccountMenu
}, _a8.shadowRootOptions = {
  ...LitElement.shadowRootOptions,
  delegatesFocus: true
}, _a8.styles = sharedStyles, _a8);
__decorate([property({ type: Object })], DAppKitConnectButton.prototype, "modalOptions", void 0);
__decorate([storeProperty()], DAppKitConnectButton.prototype, "instance", void 0);
__decorate([query("mysten-dapp-kit-connect-modal")], DAppKitConnectButton.prototype, "_modal", void 0);
DAppKitConnectButton = __decorate([customElement("mysten-dapp-kit-connect-button")], DAppKitConnectButton);

// node_modules/.pnpm/@mysten+dapp-kit-react@1.0.1_@mysten+sui@2.2.0_@types+react@19.2.10_react@19.2.4_typescript@5.9.3/node_modules/@mysten/dapp-kit-react/dist/index.mjs
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);

// node_modules/.pnpm/nanostores@1.1.0/node_modules/nanostores/task/index.js
var tasks = 0;
var resolves = [];
function startTask() {
  tasks += 1;
  return () => {
    tasks -= 1;
    if (tasks === 0) {
      let prevResolves = resolves;
      resolves = [];
      for (let i of prevResolves) i();
    }
  };
}
function task(cb) {
  let endTask = startTask();
  let promise = cb().finally(endTask);
  promise.t = true;
  return promise;
}

// node_modules/.pnpm/nanostores@1.1.0/node_modules/nanostores/clean-stores/index.js
var clean = /* @__PURE__ */ Symbol("clean");

// node_modules/.pnpm/nanostores@1.1.0/node_modules/nanostores/atom/index.js
var listenerQueue = [];
var lqIndex = 0;
var QUEUE_ITEMS_PER_LISTENER = 4;
var epoch = 0;
var atom = (initialValue) => {
  let listeners = [];
  let $atom = {
    get() {
      if (!$atom.lc) {
        $atom.listen(() => {
        })();
      }
      return $atom.value;
    },
    lc: 0,
    listen(listener) {
      $atom.lc = listeners.push(listener);
      return () => {
        for (let i = lqIndex + QUEUE_ITEMS_PER_LISTENER; i < listenerQueue.length; ) {
          if (listenerQueue[i] === listener) {
            listenerQueue.splice(i, QUEUE_ITEMS_PER_LISTENER);
          } else {
            i += QUEUE_ITEMS_PER_LISTENER;
          }
        }
        let index = listeners.indexOf(listener);
        if (~index) {
          listeners.splice(index, 1);
          if (!--$atom.lc) $atom.off();
        }
      };
    },
    notify(oldValue, changedKey) {
      epoch++;
      let runListenerQueue = !listenerQueue.length;
      for (let listener of listeners) {
        listenerQueue.push(listener, $atom.value, oldValue, changedKey);
      }
      if (runListenerQueue) {
        for (lqIndex = 0; lqIndex < listenerQueue.length; lqIndex += QUEUE_ITEMS_PER_LISTENER) {
          listenerQueue[lqIndex](
            listenerQueue[lqIndex + 1],
            listenerQueue[lqIndex + 2],
            listenerQueue[lqIndex + 3]
          );
        }
        listenerQueue.length = 0;
      }
    },
    /* It will be called on last listener unsubscribing.
       We will redefine it in onMount and onStop. */
    off() {
    },
    set(newValue) {
      let oldValue = $atom.value;
      if (oldValue !== newValue) {
        $atom.value = newValue;
        $atom.notify(oldValue);
      }
    },
    subscribe(listener) {
      let unbind = $atom.listen(listener);
      listener($atom.value);
      return unbind;
    },
    value: initialValue
  };
  if (true) {
    $atom[clean] = () => {
      listeners = [];
      $atom.lc = 0;
      $atom.off();
    };
  }
  return $atom;
};
var readonlyType = (store) => store;

// node_modules/.pnpm/nanostores@1.1.0/node_modules/nanostores/lifecycle/index.js
var MOUNT = 5;
var UNMOUNT = 6;
var REVERT_MUTATION = 10;
var on = (object, listener, eventKey, mutateStore) => {
  object.events = object.events || {};
  if (!object.events[eventKey + REVERT_MUTATION]) {
    object.events[eventKey + REVERT_MUTATION] = mutateStore((eventProps) => {
      object.events[eventKey].reduceRight((event, l) => (l(event), event), {
        shared: {},
        ...eventProps
      });
    });
  }
  object.events[eventKey] = object.events[eventKey] || [];
  object.events[eventKey].push(listener);
  return () => {
    let currentListeners = object.events[eventKey];
    let index = currentListeners.indexOf(listener);
    currentListeners.splice(index, 1);
    if (!currentListeners.length) {
      delete object.events[eventKey];
      object.events[eventKey + REVERT_MUTATION]();
      delete object.events[eventKey + REVERT_MUTATION];
    }
  };
};
var STORE_UNMOUNT_DELAY = 1e3;
var onMount = ($store, initialize) => {
  let listener = (payload) => {
    let destroy = initialize(payload);
    if (destroy) $store.events[UNMOUNT].push(destroy);
  };
  return on($store, listener, MOUNT, (runListeners) => {
    let originListen = $store.listen;
    $store.listen = (...args) => {
      if (!$store.lc && !$store.active) {
        $store.active = true;
        runListeners();
      }
      return originListen(...args);
    };
    let originOff = $store.off;
    $store.events[UNMOUNT] = [];
    $store.off = () => {
      originOff();
      setTimeout(() => {
        if ($store.active && !$store.lc) {
          $store.active = false;
          for (let destroy of $store.events[UNMOUNT]) destroy();
          $store.events[UNMOUNT] = [];
        }
      }, STORE_UNMOUNT_DELAY);
    };
    if (true) {
      let originClean = $store[clean];
      $store[clean] = () => {
        for (let destroy of $store.events[UNMOUNT]) destroy();
        $store.events[UNMOUNT] = [];
        $store.active = false;
        originClean();
      };
    }
    return () => {
      $store.listen = originListen;
      $store.off = originOff;
    };
  });
};

// node_modules/.pnpm/nanostores@1.1.0/node_modules/nanostores/computed/index.js
var computedStore = (stores, cb, batched2) => {
  if (!Array.isArray(stores)) stores = [stores];
  let previousArgs;
  let currentEpoch;
  let set = () => {
    if (currentEpoch === epoch) return;
    currentEpoch = epoch;
    let args = stores.map(($store) => $store.get());
    if (!previousArgs || args.some((arg, i) => arg !== previousArgs[i])) {
      previousArgs = args;
      let value = cb(...args);
      if (value && value.then && value.t) {
        value.then((asyncValue) => {
          if (previousArgs === args) {
            $computed.set(asyncValue);
          }
        });
      } else {
        $computed.set(value);
        currentEpoch = epoch;
      }
    }
  };
  let $computed = atom(void 0);
  let get = $computed.get;
  $computed.get = () => {
    set();
    return get();
  };
  let timer;
  let run = batched2 ? () => {
    clearTimeout(timer);
    timer = setTimeout(set);
  } : set;
  onMount($computed, () => {
    let unbinds = stores.map(($store) => $store.listen(run));
    set();
    return () => {
      for (let unbind of unbinds) unbind();
    };
  });
  return $computed;
};
var computed = (stores, fn) => computedStore(stores, fn);

// node_modules/.pnpm/nanostores@1.1.0/node_modules/nanostores/listen-keys/index.js
function listenKeys($store, keys, listener) {
  let keysSet = new Set(keys).add(void 0);
  return $store.listen((value, oldValue, changed) => {
    if (keysSet.has(changed)) {
      listener(value, oldValue, changed);
    }
  });
}

// node_modules/.pnpm/nanostores@1.1.0/node_modules/nanostores/map/index.js
var map = (initial = {}) => {
  let $map = atom(initial);
  $map.setKey = function(key, value) {
    let oldMap = $map.value;
    if (typeof value === "undefined" && key in $map.value) {
      $map.value = { ...$map.value };
      delete $map.value[key];
      $map.notify(oldMap, key);
    } else if ($map.value[key] !== value) {
      $map.value = {
        ...$map.value,
        [key]: value
      };
      $map.notify(oldMap, key);
    }
  };
  return $map;
};

// node_modules/.pnpm/@nanostores+react@1.0.0_nanostores@1.1.0_react@19.2.4/node_modules/@nanostores/react/index.js
var import_react = __toESM(require_react());
var emit = (snapshotRef, onChange) => (value) => {
  if (snapshotRef.current === value) return;
  snapshotRef.current = value;
  onChange();
};
function useStore(store, { keys, deps = [store, keys] } = {}) {
  let snapshotRef = (0, import_react.useRef)();
  snapshotRef.current = store.get();
  let subscribe = (0, import_react.useCallback)((onChange) => {
    emit(snapshotRef, onChange)(store.value);
    return keys?.length > 0 ? listenKeys(store, keys, emit(snapshotRef, onChange)) : store.listen(emit(snapshotRef, onChange));
  }, deps);
  let get = () => snapshotRef.current;
  return (0, import_react.useSyncExternalStore)(subscribe, get, get);
}

// node_modules/.pnpm/@wallet-standard+ui-registry@1.0.1/node_modules/@wallet-standard/ui-registry/lib/esm/UiWalletHandleRegistry_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.js
var uiWalletHandlesToWallets = /* @__PURE__ */ new WeakMap();
function registerWalletHandle_DO_NOT_USE_OR_YOU_WILL_BE_FIRED(uiWalletHandle, wallet) {
  uiWalletHandlesToWallets.set(uiWalletHandle, wallet);
}
function getWalletAccountForUiWalletAccount_DO_NOT_USE_OR_YOU_WILL_BE_FIRED(uiWalletAccount) {
  const wallet = getWalletForHandle_DO_NOT_USE_OR_YOU_WILL_BE_FIRED(uiWalletAccount);
  const account = wallet.accounts.find(({ address }) => address === uiWalletAccount.address);
  if (!account) {
    const err = new WalletStandardError(WALLET_STANDARD_ERROR__REGISTRY__WALLET_ACCOUNT_NOT_FOUND, {
      address: uiWalletAccount.address,
      walletName: wallet.name
    });
    safeCaptureStackTrace(err, getWalletAccountForUiWalletAccount_DO_NOT_USE_OR_YOU_WILL_BE_FIRED);
    throw err;
  }
  return account;
}
function getWalletForHandle_DO_NOT_USE_OR_YOU_WILL_BE_FIRED(uiWalletHandle) {
  const wallet = uiWalletHandlesToWallets.get(uiWalletHandle);
  if (!wallet) {
    const err = new WalletStandardError(WALLET_STANDARD_ERROR__REGISTRY__WALLET_NOT_FOUND);
    safeCaptureStackTrace(err, getWalletForHandle_DO_NOT_USE_OR_YOU_WILL_BE_FIRED);
    throw err;
  }
  return wallet;
}

// node_modules/.pnpm/@wallet-standard+ui-registry@1.0.1/node_modules/@wallet-standard/ui-registry/lib/esm/compare.js
function identifierArraysAreDifferent(a, b) {
  const itemsSetA = new Set(a);
  const itemsSetB = new Set(b);
  if (itemsSetA.size !== itemsSetB.size) {
    return true;
  }
  for (const itemFromA of itemsSetA) {
    if (!itemsSetB.has(itemFromA)) {
      return true;
    }
  }
  return false;
}

// node_modules/.pnpm/@wallet-standard+ui-registry@1.0.1/node_modules/@wallet-standard/ui-registry/lib/esm/UiWalletAccountRegistry_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.js
var walletAccountsToUiWalletAccounts = /* @__PURE__ */ new WeakMap();
function getOrCreateUiWalletAccountForStandardWalletAccount_DO_NOT_USE_OR_YOU_WILL_BE_FIRED(wallet, account) {
  let existingUiWalletAccount = walletAccountsToUiWalletAccounts.get(account);
  if (existingUiWalletAccount) {
    try {
      if (getWalletForHandle_DO_NOT_USE_OR_YOU_WILL_BE_FIRED(existingUiWalletAccount) !== wallet) {
        existingUiWalletAccount = void 0;
      }
    } catch {
      existingUiWalletAccount = void 0;
    }
  }
  const mustInitialize = !existingUiWalletAccount;
  let uiWalletAccount = existingUiWalletAccount ?? {};
  let isDirty = !existingUiWalletAccount;
  function dirtyUiWallet() {
    if (!isDirty) {
      uiWalletAccount = { ...uiWalletAccount };
      isDirty = true;
    }
  }
  if (mustInitialize || identifierArraysAreDifferent(uiWalletAccount.chains, account.chains)) {
    dirtyUiWallet();
    uiWalletAccount.chains = Object.freeze([...account.chains]);
  }
  if (mustInitialize || identifierArraysAreDifferent(uiWalletAccount.features, account.features)) {
    dirtyUiWallet();
    uiWalletAccount.features = Object.freeze([...account.features]);
  }
  if (mustInitialize || uiWalletAccount.address !== account.address || uiWalletAccount.icon !== account.icon || uiWalletAccount.label !== account.label || uiWalletAccount.publicKey !== account.publicKey) {
    dirtyUiWallet();
    uiWalletAccount.address = account.address;
    uiWalletAccount.icon = account.icon;
    uiWalletAccount.label = account.label;
    uiWalletAccount.publicKey = account.publicKey;
  }
  if (isDirty) {
    walletAccountsToUiWalletAccounts.set(account, uiWalletAccount);
    registerWalletHandle_DO_NOT_USE_OR_YOU_WILL_BE_FIRED(uiWalletAccount, wallet);
  }
  return Object.freeze(uiWalletAccount);
}

// node_modules/.pnpm/@wallet-standard+ui-registry@1.0.1/node_modules/@wallet-standard/ui-registry/lib/esm/UiWalletRegistry_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.js
var walletsToUiWallets = /* @__PURE__ */ new WeakMap();
function getOrCreateUiWalletForStandardWallet_DO_NOT_USE_OR_YOU_WILL_BE_FIRED(wallet) {
  const existingUiWallet = walletsToUiWallets.get(wallet);
  const mustInitialize = !existingUiWallet;
  let uiWallet = existingUiWallet ?? {};
  let isDirty = !existingUiWallet;
  function dirtyUiWallet() {
    if (!isDirty) {
      uiWallet = { ...uiWallet };
      isDirty = true;
    }
  }
  const nextUiWalletAccounts = {
    _cache: [],
    *[Symbol.iterator]() {
      if (this._cache.length) {
        yield* this._cache;
      }
      for (const walletAccount of wallet.accounts.slice(this._cache.length)) {
        const uiWalletAccount = getOrCreateUiWalletAccountForStandardWalletAccount_DO_NOT_USE_OR_YOU_WILL_BE_FIRED(wallet, walletAccount);
        this._cache.push(uiWalletAccount);
        yield uiWalletAccount;
      }
    },
    some(predicateFn) {
      if (this._cache.some(predicateFn)) {
        return true;
      }
      for (const walletAccount of wallet.accounts.slice(this._cache.length)) {
        const uiWalletAccount = getOrCreateUiWalletAccountForStandardWalletAccount_DO_NOT_USE_OR_YOU_WILL_BE_FIRED(wallet, walletAccount);
        this._cache.push(uiWalletAccount);
        if (predicateFn(uiWalletAccount)) {
          return true;
        }
      }
      return false;
    },
    get length() {
      return wallet.accounts.length;
    }
  };
  if (mustInitialize || uiWallet.accounts.length !== wallet.accounts.length || nextUiWalletAccounts.some((account) => !uiWallet.accounts.includes(account))) {
    dirtyUiWallet();
    uiWallet.accounts = Object.freeze(Array.from(nextUiWalletAccounts));
  }
  if (mustInitialize || identifierArraysAreDifferent(uiWallet.features, Object.keys(wallet.features))) {
    dirtyUiWallet();
    uiWallet.features = Object.freeze(Object.keys(wallet.features));
  }
  if (mustInitialize || identifierArraysAreDifferent(uiWallet.chains, wallet.chains)) {
    dirtyUiWallet();
    uiWallet.chains = Object.freeze([...wallet.chains]);
  }
  if (mustInitialize || uiWallet.icon !== wallet.icon || uiWallet.name !== wallet.name || uiWallet.version !== wallet.version) {
    dirtyUiWallet();
    uiWallet.icon = wallet.icon;
    uiWallet.name = wallet.name;
    uiWallet.version = wallet.version;
  }
  if (isDirty) {
    walletsToUiWallets.set(wallet, uiWallet);
    registerWalletHandle_DO_NOT_USE_OR_YOU_WILL_BE_FIRED(uiWallet, wallet);
  }
  return Object.freeze(uiWallet);
}

// node_modules/.pnpm/@wallet-standard+ui-compare@1.0.1/node_modules/@wallet-standard/ui-compare/lib/esm/compare.js
function uiWalletAccountsAreSame(a, b) {
  if (a.address !== b.address) {
    return false;
  }
  const underlyingWalletA = getWalletForHandle_DO_NOT_USE_OR_YOU_WILL_BE_FIRED(a);
  const underlyingWalletB = getWalletForHandle_DO_NOT_USE_OR_YOU_WILL_BE_FIRED(b);
  return underlyingWalletA === underlyingWalletB;
}
function uiWalletAccountBelongsToUiWallet(account, wallet) {
  const underlyingWalletForUiWallet = getWalletForHandle_DO_NOT_USE_OR_YOU_WILL_BE_FIRED(wallet);
  const underlyingWalletForUiWalletAccount = getWalletForHandle_DO_NOT_USE_OR_YOU_WILL_BE_FIRED(account);
  return underlyingWalletForUiWallet === underlyingWalletForUiWalletAccount;
}

// node_modules/.pnpm/@wallet-standard+ui-features@1.0.1/node_modules/@wallet-standard/ui-features/lib/esm/getWalletFeature.js
function getWalletFeature(uiWalletHandle, featureName) {
  const wallet = getWalletForHandle_DO_NOT_USE_OR_YOU_WILL_BE_FIRED(uiWalletHandle);
  if (!(featureName in wallet.features)) {
    const err = new WalletStandardError(WALLET_STANDARD_ERROR__FEATURES__WALLET_FEATURE_UNIMPLEMENTED, {
      featureName,
      supportedChains: [...wallet.chains],
      supportedFeatures: Object.keys(wallet.features),
      walletName: wallet.name
    });
    safeCaptureStackTrace(err, getWalletFeature);
    throw err;
  }
  return wallet.features[featureName];
}

// node_modules/.pnpm/@wallet-standard+ui-features@1.0.1/node_modules/@wallet-standard/ui-features/lib/esm/getWalletAccountFeature.js
function getWalletAccountFeature(walletAccount, featureName) {
  if (!walletAccount.features.includes(featureName)) {
    const err = new WalletStandardError(WALLET_STANDARD_ERROR__FEATURES__WALLET_ACCOUNT_FEATURE_UNIMPLEMENTED, {
      address: walletAccount.address,
      featureName,
      supportedChains: [...walletAccount.chains],
      supportedFeatures: [...walletAccount.features]
    });
    safeCaptureStackTrace(err, getWalletAccountFeature);
    throw err;
  }
  return getWalletFeature(walletAccount, featureName);
}

// node_modules/.pnpm/@mysten+dapp-kit-core@1.0.2_@mysten+sui@2.2.0_typescript@5.9.3/node_modules/@mysten/dapp-kit-core/dist/index.mjs
var DAppKitError = class extends Error {
};
var WalletNotConnectedError = class extends DAppKitError {
};
var ChainNotSupportedError = class extends DAppKitError {
};
var FeatureNotSupportedError = class extends DAppKitError {
};
var WalletNoAccountsConnectedError = class extends DAppKitError {
};
var WalletAccountNotFoundError = class extends DAppKitError {
};
function getChain(network) {
  return `sui:${network}`;
}
function createNetworkConfig(networks, createClient) {
  if (networks.length === 0) throw new DAppKitError("You must specify at least one Sui network for your application.");
  const networkConfig = /* @__PURE__ */ new Map();
  function getClient(network) {
    if (networkConfig.has(network)) return networkConfig.get(network);
    const client = createClient(network);
    networkConfig.set(network, client);
    return client;
  }
  return {
    networkConfig: Object.freeze(networkConfig),
    getClient
  };
}
var requiredWalletFeatures = [StandardConnect, StandardEvents];
var signingFeatures = [SuiSignTransaction, SuiSignTransactionBlock];
function getAssociatedWalletOrThrow(account, wallets) {
  const wallet = wallets.find((wallet$1) => uiWalletAccountBelongsToUiWallet(account, wallet$1));
  if (!wallet) throw new DAppKitError(`Wallet not found for account ${account.address}.`);
  return wallet;
}
function getWalletUniqueIdentifier(walletHandle) {
  const underlyingWallet = getWalletForHandle_DO_NOT_USE_OR_YOU_WILL_BE_FIRED(walletHandle);
  return underlyingWallet.id ?? underlyingWallet.name;
}
function getAccountFeature({ account, featureName, chain }) {
  if (!account.chains.includes(chain)) {
    const cause = new WalletStandardError(WALLET_STANDARD_ERROR__FEATURES__WALLET_ACCOUNT_CHAIN_UNSUPPORTED, {
      chain,
      featureName,
      supportedChains: [...account.chains],
      supportedFeatures: [...account.features],
      address: account.address
    });
    throw new ChainNotSupportedError(`The account ${cause.context.address} does not support the chain "${cause.context.chain}".`, { cause });
  }
  try {
    return getWalletAccountFeature(account, featureName);
  } catch (error) {
    throw new FeatureNotSupportedError(`The account ${account.address} does not support the feature "${featureName}".`, { cause: error });
  }
}
function tryGetAccountFeature(...args) {
  try {
    return getAccountFeature(...args);
  } catch (error) {
    if (error instanceof FeatureNotSupportedError) return null;
    throw error;
  }
}
function createStores({ defaultNetwork, getClient }) {
  const $baseConnection = map({
    status: "disconnected",
    currentAccount: null
  });
  const $currentNetwork = atom(defaultNetwork);
  const $registeredWallets = atom([]);
  const $compatibleWallets = computed([$registeredWallets, $currentNetwork], (wallets, currentNetwork) => {
    return wallets.filter((wallet) => {
      const areChainsCompatible = wallet.chains.some((chain) => getChain(currentNetwork) === chain);
      const hasRequiredFeatures = requiredWalletFeatures.every((featureName) => wallet.features.includes(featureName));
      const canSignTransactions = signingFeatures.some((featureName) => wallet.features.includes(featureName));
      return areChainsCompatible && hasRequiredFeatures && canSignTransactions;
    });
  });
  return {
    $currentNetwork,
    $registeredWallets,
    $compatibleWallets,
    $baseConnection,
    $currentClient: computed($currentNetwork, getClient),
    $connection: computed([$baseConnection, $compatibleWallets], (connection, wallets) => {
      switch (connection.status) {
        case "connected":
          return {
            wallet: getAssociatedWalletOrThrow(connection.currentAccount, wallets),
            account: connection.currentAccount,
            status: connection.status,
            supportedIntents: connection.supportedIntents,
            isConnected: true,
            isConnecting: false,
            isReconnecting: false,
            isDisconnected: false
          };
        case "connecting":
          return {
            wallet: null,
            account: connection.currentAccount,
            status: connection.status,
            supportedIntents: [],
            isConnected: false,
            isConnecting: true,
            isReconnecting: false,
            isDisconnected: false
          };
        case "reconnecting":
          return {
            wallet: getAssociatedWalletOrThrow(connection.currentAccount, wallets),
            account: connection.currentAccount,
            status: connection.status,
            supportedIntents: connection.supportedIntents,
            isConnected: false,
            isConnecting: false,
            isReconnecting: true,
            isDisconnected: false
          };
        case "disconnected":
          return {
            wallet: null,
            account: connection.currentAccount,
            status: connection.status,
            supportedIntents: [],
            isConnected: false,
            isConnecting: false,
            isReconnecting: false,
            isDisconnected: true
          };
        default:
          throw new Error(`Encountered unknown connection status: ${connection}`);
      }
    })
  };
}
function syncRegisteredWallets({ $registeredWallets }) {
  onMount($registeredWallets, () => {
    const walletsApi = getWallets();
    const unsubscribeCallbacksByWallet = /* @__PURE__ */ new Map();
    const onWalletsChanged = () => {
      const wallets = walletsApi.get();
      $registeredWallets.set(wallets.map(getOrCreateUiWalletForStandardWallet_DO_NOT_USE_OR_YOU_WILL_BE_FIRED));
    };
    const subscribeToWalletEvents = (wallet) => {
      const unsubscribeFromChange = wallet.features[StandardEvents].on("change", () => {
        onWalletsChanged();
      });
      unsubscribeCallbacksByWallet.set(wallet, unsubscribeFromChange);
    };
    const unsubscribeFromRegister = walletsApi.on("register", (...addedWallets) => {
      addedWallets.filter(hasStandardEvents).forEach(subscribeToWalletEvents);
      onWalletsChanged();
    });
    const unsubscribeFromUnregister = walletsApi.on("unregister", (...removedWallets) => {
      removedWallets.filter(hasStandardEvents).forEach((wallet) => {
        const unsubscribeFromChange = unsubscribeCallbacksByWallet.get(wallet);
        if (unsubscribeFromChange) {
          unsubscribeCallbacksByWallet.delete(wallet);
          unsubscribeFromChange();
        }
      });
      onWalletsChanged();
    });
    walletsApi.get().filter(hasStandardEvents).forEach(subscribeToWalletEvents);
    onWalletsChanged();
    return () => {
      unsubscribeFromRegister();
      unsubscribeFromUnregister();
      unsubscribeCallbacksByWallet.forEach((unsubscribe) => unsubscribe());
      unsubscribeCallbacksByWallet.clear();
    };
  });
}
function hasStandardEvents(wallet) {
  return StandardEvents in wallet.features;
}
function connectWalletCreator({ $baseConnection }, supportedNetworks) {
  return async function connectWallet({ wallet, account, ...standardConnectArgs }) {
    return await task(async () => {
      const isAlreadyConnected = $baseConnection.get().status === "connected";
      try {
        $baseConnection.setKey("status", isAlreadyConnected ? "reconnecting" : "connecting");
        const { accounts: suiAccounts, supportedIntents } = await internalConnectWallet(wallet, supportedNetworks, standardConnectArgs);
        if (!isAlreadyConnected && suiAccounts.length === 0) throw new WalletNoAccountsConnectedError("No accounts were authorized.");
        if (account && !uiWalletAccountBelongsToUiWallet(account, wallet)) throw new WalletAccountNotFoundError(`No account with address ${account.address} is authorized for ${wallet.name}.`);
        $baseConnection.set({
          status: "connected",
          currentAccount: account ?? suiAccounts[0],
          supportedIntents: supportedIntents ?? []
        });
        return { accounts: suiAccounts };
      } catch (error) {
        $baseConnection.setKey("status", isAlreadyConnected ? "connected" : "disconnected");
        throw error;
      }
    });
  };
}
async function internalConnectWallet(wallet, supportedNetworks, args) {
  const { connect } = getWalletFeature(wallet, StandardConnect);
  const result = await connect(args);
  const underlyingWallet = getWalletForHandle_DO_NOT_USE_OR_YOU_WILL_BE_FIRED(wallet);
  const supportedChains = supportedNetworks.map(getChain);
  const supportedIntents = result.supportedIntents ?? await getSupportedIntentsFromFeature(wallet);
  return {
    accounts: result.accounts.filter((account) => account.chains.some((chain) => supportedChains.includes(chain))).map(getOrCreateUiWalletAccountForStandardWalletAccount_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.bind(null, underlyingWallet)),
    supportedIntents
  };
}
async function getSupportedIntentsFromFeature(wallet) {
  if (!wallet.features.includes("sui:getCapabilities")) return [];
  return (await getWalletFeature(wallet, "sui:getCapabilities")?.getCapabilities())?.supportedIntents ?? [];
}
function autoConnectWallet({ networks, stores: { $baseConnection, $compatibleWallets }, storage, storageKey }) {
  onMount($compatibleWallets, () => {
    return $compatibleWallets.listen(async (wallets, oldWallets) => {
      if (oldWallets && oldWallets.length > wallets.length) return;
      if ($baseConnection.get().status !== "disconnected") return;
      const savedWalletAccount = await task(() => {
        return getSavedWalletAccount({
          networks,
          storage,
          storageKey,
          wallets
        });
      });
      if (savedWalletAccount) $baseConnection.set({
        status: "connected",
        currentAccount: savedWalletAccount.account,
        supportedIntents: savedWalletAccount.supportedIntents
      });
    });
  });
}
async function getSavedWalletAccount({ networks, storage, storageKey, wallets }) {
  const savedWalletIdAndAddress = await storage.getItem(storageKey);
  if (!savedWalletIdAndAddress) return null;
  const [savedWalletId, savedAccountAddress, savedIntents] = savedWalletIdAndAddress.split(":");
  if (!savedWalletId || !savedAccountAddress) return null;
  const targetWallet = wallets.find((wallet) => getWalletUniqueIdentifier(wallet) === savedWalletId);
  if (!targetWallet) return null;
  const existingAccount = targetWallet.accounts.find((account$1) => account$1.address === savedAccountAddress);
  if (existingAccount) return {
    account: existingAccount,
    supportedIntents: (savedIntents ? savedIntents.split(",") : null) ?? await getSupportedIntentsFromFeature(targetWallet)
  };
  const { accounts: alreadyAuthorizedAccounts, supportedIntents } = await internalConnectWallet(targetWallet, networks, { silent: true });
  const account = alreadyAuthorizedAccounts.find((account$1) => account$1.address === savedAccountAddress);
  return account ? {
    account,
    supportedIntents
  } : null;
}
var DEFAULT_STORAGE_KEY = "mysten-dapp-kit:selected-wallet-and-address";
function getDefaultStorage() {
  return isLocalStorageAvailable() ? localStorage : createInMemoryStorage();
}
function createInMemoryStorage() {
  const store = /* @__PURE__ */ new Map();
  return {
    getItem(key) {
      return store.get(key) ?? null;
    },
    setItem(key, value) {
      store.set(key, value);
    },
    removeItem(key) {
      store.delete(key);
    }
  };
}
function isLocalStorageAvailable() {
  try {
    const testKey = "__storage_test__";
    localStorage.setItem(testKey, "test");
    localStorage.removeItem(testKey);
    return true;
  } catch {
    return false;
  }
}
function syncStateToStorage({ stores: { $connection }, storage, storageKey }) {
  onMount($connection, () => {
    return $connection.listen((connection, oldConnection) => {
      if (!oldConnection || oldConnection.status === connection.status) return;
      if (connection.account) storage.setItem(storageKey, getSavedAccountStorageKey(connection.account, connection.supportedIntents));
      else storage.removeItem(storageKey);
    });
  });
}
function getSavedAccountStorageKey(account, supportedIntents) {
  return `${getWalletUniqueIdentifier(account).replace(":", "_")}:${account.address}:${supportedIntents.join(",")}:`;
}
function manageWalletConnection({ $compatibleWallets, $baseConnection }) {
  onMount($compatibleWallets, () => {
    return $compatibleWallets.listen(async (wallets) => {
      const connection = $baseConnection.get();
      if (connection.status !== "connected") return;
      const resolvedAccount = resolveWalletAccount(connection.currentAccount, wallets);
      if (resolvedAccount) $baseConnection.setKey("currentAccount", resolvedAccount);
      else $baseConnection.set({
        status: "disconnected",
        currentAccount: null
      });
    });
  });
}
function resolveWalletAccount(currentAccount, wallets) {
  for (const wallet of wallets) {
    for (const walletAccount of wallet.accounts) if (uiWalletAccountsAreSame(currentAccount, walletAccount)) return walletAccount;
    if (uiWalletAccountBelongsToUiWallet(currentAccount, wallet) && wallet.accounts[0]) return wallet.accounts[0];
  }
  return null;
}
function switchNetworkCreator({ $currentNetwork }) {
  return function switchNetwork(network) {
    $currentNetwork.set(network);
  };
}
function disconnectWalletCreator({ $baseConnection, $connection }) {
  return async function disconnectWallet(...standardDisconnectArgs) {
    return await task(async () => {
      const { wallet } = $connection.get();
      if (!wallet) throw new WalletNotConnectedError("No wallet is connected.");
      try {
        const { disconnect } = getWalletFeature(wallet, StandardDisconnect);
        await disconnect(...standardDisconnectArgs);
      } catch (error) {
        console.warn("Failed to disconnect the current wallet from the application.", error);
      } finally {
        $baseConnection.set({
          status: "disconnected",
          currentAccount: null
        });
      }
    });
  };
}
function switchAccountCreator({ $baseConnection, $connection }) {
  return function switchAccount({ account }) {
    const { wallet } = $connection.get();
    if (!wallet) throw new WalletNotConnectedError("No wallet is connected.");
    if (!uiWalletAccountBelongsToUiWallet(account, wallet)) throw new WalletAccountNotFoundError(`No account with address ${account.address} is connected to ${wallet.name}.`);
    $baseConnection.setKey("currentAccount", account);
  };
}
function signPersonalMessageCreator({ $connection, $currentNetwork }) {
  return async function signPersonalMessage({ ...standardArgs }) {
    const { account } = $connection.get();
    if (!account) throw new WalletNotConnectedError("No wallet is connected.");
    const chain = getChain($currentNetwork.get());
    return await getAccountFeature({
      account,
      chain,
      featureName: SuiSignPersonalMessage
    }).signPersonalMessage({
      ...standardArgs,
      account: getWalletAccountForUiWalletAccount_DO_NOT_USE_OR_YOU_WILL_BE_FIRED(account),
      chain
    });
  };
}
function buildTransactionResult(digest, signature, transactionBytes, effectsBytes) {
  const status = extractStatusFromEffectsBcs(effectsBytes);
  let effects = null;
  try {
    effects = parseTransactionEffectsBcs(effectsBytes);
  } catch {
    console.warn("Parsing transaction effects failed, you may need to update the SDK to pickup the latest bcs types");
  }
  const txResult = {
    digest,
    signatures: [signature],
    epoch: null,
    status,
    effects,
    transaction: parseTransactionBcs(transactionBytes),
    balanceChanges: void 0,
    events: void 0,
    objectTypes: void 0,
    bcs: transactionBytes
  };
  return status.success ? {
    $kind: "Transaction",
    Transaction: txResult
  } : {
    $kind: "FailedTransaction",
    FailedTransaction: txResult
  };
}
function signAndExecuteTransactionCreator({ $connection, $currentClient }) {
  return async function signAndExecuteTransaction({ transaction, ...standardArgs }) {
    const { account, supportedIntents } = $connection.get();
    if (!account) throw new WalletNotConnectedError("No wallet is connected.");
    const underlyingAccount = getWalletAccountForUiWalletAccount_DO_NOT_USE_OR_YOU_WILL_BE_FIRED(account);
    const suiClient = $currentClient.get();
    const chain = getChain(suiClient.network);
    const transactionWrapper = { toJSON: async () => {
      if (typeof transaction === "string") return transaction;
      transaction.setSenderIfNotSet(account.address);
      return await transaction.toJSON({
        client: suiClient,
        supportedIntents
      });
    } };
    const signAndExecuteTransactionFeature = tryGetAccountFeature({
      account,
      chain,
      featureName: SuiSignAndExecuteTransaction
    });
    if (signAndExecuteTransactionFeature) {
      const result = await signAndExecuteTransactionFeature.signAndExecuteTransaction({
        ...standardArgs,
        account: underlyingAccount,
        transaction: transactionWrapper,
        chain
      });
      const transactionBytes = fromBase64(result.bytes);
      const effectsBytes = fromBase64(result.effects);
      return buildTransactionResult(result.digest, result.signature, transactionBytes, effectsBytes);
    }
    const signAndExecuteTransactionBlockFeature = tryGetAccountFeature({
      account,
      chain,
      featureName: SuiSignAndExecuteTransactionBlock
    });
    if (signAndExecuteTransactionBlockFeature) {
      const transactionBlock = Transaction.from(await transactionWrapper.toJSON());
      const { digest, rawEffects, rawTransaction } = await signAndExecuteTransactionBlockFeature.signAndExecuteTransactionBlock({
        account,
        chain,
        transactionBlock,
        options: {
          showRawEffects: true,
          showRawInput: true
        }
      });
      const [{ txSignatures: [signature], intentMessage: { value: bcsTransaction } }] = suiBcs.SenderSignedData.parse(fromBase64(rawTransaction));
      return buildTransactionResult(digest, signature, suiBcs.TransactionData.serialize(bcsTransaction).toBytes(), new Uint8Array(rawEffects));
    }
    throw new FeatureNotSupportedError(`The account ${account.address} does not support signing and executing transactions.`);
  };
}
function signTransactionCreator({ $connection, $currentClient }) {
  return async function signTransaction({ transaction, ...standardArgs }) {
    const { account, supportedIntents } = $connection.get();
    if (!account) throw new WalletNotConnectedError("No wallet is connected.");
    const underlyingAccount = getWalletAccountForUiWalletAccount_DO_NOT_USE_OR_YOU_WILL_BE_FIRED(account);
    const suiClient = $currentClient.get();
    const chain = getChain(suiClient.network);
    const transactionWrapper = { toJSON: async () => {
      if (typeof transaction === "string") return transaction;
      transaction.setSenderIfNotSet(account.address);
      return await transaction.toJSON({
        client: suiClient,
        supportedIntents
      });
    } };
    const signTransactionFeature = tryGetAccountFeature({
      account,
      chain,
      featureName: SuiSignTransaction
    });
    if (signTransactionFeature) return await signTransactionFeature.signTransaction({
      ...standardArgs,
      transaction: transactionWrapper,
      account: underlyingAccount,
      chain
    });
    const signTransactionBlockFeature = tryGetAccountFeature({
      account,
      chain,
      featureName: SuiSignTransactionBlock
    });
    if (signTransactionBlockFeature) {
      const transaction$1 = Transaction.from(await transactionWrapper.toJSON());
      const { transactionBlockBytes, signature } = await signTransactionBlockFeature.signTransactionBlock({
        transactionBlock: transaction$1,
        account: underlyingAccount,
        chain
      });
      return {
        bytes: transactionBlockBytes,
        signature
      };
    }
    throw new FeatureNotSupportedError(`The account ${account.address} does not support signing transactions.`);
  };
}
function slushWebWalletInitializer(config) {
  return {
    id: "slush-web-wallet-initializer",
    async initialize() {
      const result = await registerSlushWallet(config?.appName || getDefaultAppName(), {
        origin: config?.origin,
        metadataApiUrl: config?.metadataApiUrl
      });
      if (!result) throw new Error("Registration un-successful.");
      return { unregister: result.unregister };
    }
  };
}
function getDefaultAppName() {
  return document.querySelector(`meta[name="application-name"]`)?.content || document.title;
}
var initializerMap = /* @__PURE__ */ new Map();
async function registerAdditionalWallets(initializers, args) {
  initializerMap.forEach((unregister) => unregister());
  initializerMap.clear();
  const initializePromises = [...new Map(initializers.map((init) => [init.id, init])).values()].map(async (initializer) => {
    return {
      initializer,
      result: await initializer.initialize(args)
    };
  });
  const initializerResults = await Promise.allSettled(initializePromises);
  for (const settledResult of initializerResults) if (settledResult.status === "fulfilled") {
    const { initializer, result } = settledResult.value;
    initializerMap.set(initializer.id, result.unregister);
  } else console.warn(`Skipping wallet initializer: "${settledResult.reason}".`);
}
function unsafeBurnerWalletInitializer() {
  return {
    id: "unsafe-burner-initalizer",
    async initialize({ networks, getClient }) {
      const wallet = new UnsafeBurnerWallet({ clients: networks.map(getClient) });
      return { unregister: getWallets().register(wallet) };
    }
  };
}
var UnsafeBurnerWallet = class {
  #chainConfig;
  #keypair = new Ed25519Keypair();
  #account;
  constructor({ clients }) {
    this.#chainConfig = clients.reduce((accumulator, client) => {
      const chain = getChain(client.network);
      accumulator[chain] = client;
      return accumulator;
    }, {});
    this.#account = new ReadonlyWalletAccount({
      address: this.#keypair.getPublicKey().toSuiAddress(),
      publicKey: this.#keypair.getPublicKey().toSuiBytes(),
      chains: this.chains,
      features: [
        SuiSignTransaction,
        SuiSignAndExecuteTransaction,
        SuiSignPersonalMessage
      ]
    });
    console.warn("Your application is currently using the unsafe burner wallet. Make sure that this wallet is disabled in production.");
  }
  get version() {
    return "1.0.0";
  }
  get name() {
    return "Unsafe Burner Wallet";
  }
  get icon() {
    return "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8CAYAAAA6/NlyAAAJrElEQVR42tWbe2xT1x3H7UxAyD3XrdrSbGXlUbKWsq5rWdVuVOMRSEqSOmnVRZMmJqZNYv1nf3R/jWmVmVrtRRM/YwPd1nVTNcrE3pQCoikrIRAC4VVNY0hlD9ZOo1uCfe3ra9979v0dcy3s5Pper76Oh/STE+495/4+5/c85zqe2f7HAx5vKsS+monJj/CdHi/f4/HWW4f6AwdblmXjTM0NyS+movKtw9v+j6C5gKhyTMTTpA2x15Qwy+Pz75motOGdgKep8WF5ATgVZIt5NeO2wMqD0hfVGNPh3oYaYflsjG0l63PeyLCDnqbsLpZIhaRNFI+Ox+Le5KB0RybK8gDmJOkI07U4i/FhT1NDQl8Me5rUIfaDfELOJ0NsFa/SJQHm1WLsHcDqRWiy9BCL8s0N5t6UWWFVvxplejYm60hC91cNjPtzCTZsAptCVoeLP8PDDQJNCSodap6H+LtE8ZcdkvVkkD38vwDn4/Jvy4EhBhZSvRaUHiTXn31gJJxkUPoClBKKFizM+inhVA2cYIdM4HJouPvoe9s9H+KzDhyGK6KkmIqitBhww2C11rjQL2L4kgUwFxk8yPyzauUA3Pk/353XnA6zKbKCaQ2UlMvJF6W5uF5F8yHfZWZpC9HRmBziaEpm1bpY9XvhxuWJRldC7Mt03WlZwpjnkZUNa2DMG2EaPj9MGd2l2mofd0hQ7ZSopsXckHxVCUp32fXGdD0ZktrgFUmMqwhcWFjp87RArsD+9bn585IRaSHAKgBL3SZwOTRc8BKg7yYoskp5OJDiiPmF2Sj7ox0siYJ7lJA04EqvzZ9B1xSVt6PlW0IxZgUMJdZYAJuWngLQt9IRuZXmoTEkmci8ZtTXTViUKyasA9FRun5d8z6bfw0gYWm9mmCXxZatQgxfC7I2NVpRYQOxKWppLs4mcgn5NcibgL1K40xYp8CYY5TXEpjcb3LAJ0OZyyg3+2nySm6fjEtzkEz+7VBx3RTb+60z9dma7pkvwO2QQL5HzTtAdpKF7euw/HuzfrosBHy+ZsBimzbQshjWTVMDgez53B5MbjcGbr1ZjdUJOM5O0SLXzJ2R+uOA1dMAVoLsm5zb73JSId8t8Aa1LsAJdoTCrCaw6e3NC2DdFMUXWRg173mysJNOSUNskUJ1cOlXa2LhcbgmSszXYSn9hl3KSxTDjrZ2cbbfbWDyumsh9m3e7zCG7a3ETt+gtI7fx6lEOanZKDVvuA2cjYmt5xNOd2Louz3IQ12UZ2Zo3lkb9cDlvSs6m4Vk5Yqlabs0B97wT7PUuCXQz0Bnt9QxMPTW4iwBtmUlY8hFsHJPlzcQ1xuG75CVK1kXofCUGnU9fg1aVD7kfE9MoabtYkcAvIUYS2op3Hc3TTrDQzIAeojugTVLFolWDR6wFPtY0R66n6HltwjCIawnE2ymresk9NtN+pfUUi0mX6RJLfrh9zMRaRPOqubSA8W2MNzC0mHpK7j2ruuw5mYkxl5+2+HGQeg4yNYg7vNg+xMxFsuRMuiTsRJZG3cysAl4D9n4aC4un8L9qUyVvbCyYwFXX1nGUxFf1cCiEQqy75O+TpMwYKNKSPQUqhLyyWLsRbESLctx0YnixgfphRWA8pOPc+N4F9d+eV9V4OlCX/As5w5g+wtGhJGukp5go2R3D7EW9rSDcnGL56YgJHj+8GcFND/Vy41jj/H0jxc6HU/AA2QlR01UlH3D7CmITQnJq4lVWBi1yl8XYEh278c5H++F+Iui7r7bYR8tH/gbqoJN7fVODUhLYVVxzmYCEyOxFg7RUVa0egCHZZ55eRHnp/tKgMna6s/bbMdTxZgMzl9CCcmq7k690OzDfaeSN4QcsREjsQpgXHwyWyfg9K5WE7hc6JqTWjyihObfygOFOkv6i5K5TZx8LsL1sVS4NL8ItiB7sgAcEKcWHfUCVhK3kUVnBNbfXIs4l5xAv5sJs234eTUy93L0Au2otQOw5ORMyfQ6WwexFupVSHowG6uThXfebmlhWojMS3fazmMeGxEI6S2SUti6RAo2vKohVuH3qUG5FWm/PjH8kzutgSH5g58xrVwzIbZkxHf7OFjFC+wrMDXcpOqOKX/g01U/XPvVJyxdWsiJblqYmnZoWbDxAcR56X5WPuh4ewcL5PY9JBRUYjc7fzjG6Uc3mHBWbg23X1BLaFHOSnrw4bWiNAXSEWcWRntIignXTP/oDsfKZX66mMbZAPfhviU1AyYmJLYAMZa/QXjUSeIiixpj3UUFtd884KytjN7EjdGNNMbWwtlf3FvbQ4OQtIoYSzbxqVDLXMTxP8jnnbiyKcaJLvueGLD6kXW2sKZov1tpn7hwXf3ZUvq0K2FXOM7Op/Xgb6PhxsWIErYGVuK3WGXWkkwMMZVCVl5kWtax5A6usgemvnx4DelUcYcFC0eIbcbXKzggeyBjeXIhkftaKknJKLtnuSg7KmKQsrH+1nqbmLWY6w/tBGy/8xrruR5SM99LLIjfT/4ZbNZnQEPssIVb21rKTGRIPDagNoLdFMKgcuLc/TF6Bulk6c7ovg4TU+XvS6FNw1tDfVqH9MOPmBDui0hcK6wz744FlDjNe0m3aVldJYagtI6YbF+3ZGPsQHlN1vbeh8lJofqJ+uo9Zi4wXZxKFiXKGxbHT7pNq71oNg4Qi6MviE0FpRVqjGXILYoJ4tCjdYU1rWeMdPLc/ochj3B9pGNGL4NupGPRlUl35KMVxFLNO6ZnxYlBsUPqoMkbUqAb6VhMVKQ7MVT1dYdrL8hzEAcjpmvjHKphgaFb0ZVJZw7dwVD9q5fkgPTRbBxnzmGfgRLQsMCkG+moQdcp6GzzZsL2MGyllvBNGWM9RqMCk26kI7aBK526csVShZTfzid6FEzeiNAGP92jpCPQEbrW7EW5MbZxAz/fN9lg0IbQaaxrQ83/VoKPb/HqJx67Hw+43CDQBPsX0gm6ufXNvH4vP9rZapzx7+Nn+oxZAjfo2caZ3n350c5W6FSEdQ86sNarj3c/jRV+H42AXsdGRBfPPIlnb/mUtxzWXfALn/PmRze2Gud6E/xsXwYtnlsWN8Tc5/oyxjn/jvyJrlY82xLUfWuPr/TqxzuXQZkIP9M7CXiyuP4B4WmsTnNhzinjrD+WO9bRhmdZWLXe4EKRtV5tpN3Hx3s2G+d79/MJf4qff0LnE72kfFEs4ITQvWLMab8C131dP9n9Je1Yx000Nz2jAf+UJwCBchc3NvGR1Qx71XXY2Ww1Jvx7YalzAPkX9rp5E5Z+pv+ja8bE43uN491b9dHO9Xx4lUxziLn21Nai/wXWM6t9vkvtrwAAAABJRU5ErkJggg==";
  }
  get chains() {
    return Object.keys(this.#chainConfig);
  }
  get accounts() {
    return [this.#account];
  }
  get features() {
    return {
      [StandardConnect]: {
        version: "1.0.0",
        connect: this.#connect
      },
      [StandardEvents]: {
        version: "1.0.0",
        on: this.#on
      },
      [SuiSignPersonalMessage]: {
        version: "1.1.0",
        signPersonalMessage: this.#signPersonalMessage
      },
      [SuiSignTransaction]: {
        version: "2.0.0",
        signTransaction: this.#signTransaction
      },
      [SuiSignAndExecuteTransaction]: {
        version: "2.0.0",
        signAndExecuteTransaction: this.#signAndExecuteTransaction
      }
    };
  }
  #on = () => {
    return () => {
    };
  };
  #connect = async () => {
    return { accounts: this.accounts };
  };
  #signPersonalMessage = async (messageInput) => {
    return await this.#keypair.signPersonalMessage(messageInput.message);
  };
  #signTransaction = async ({ transaction, signal, chain }) => {
    signal?.throwIfAborted();
    const client = this.#chainConfig[chain];
    if (!client) throw new Error(`Invalid chain "${chain}" specified.`);
    const builtTransaction = await Transaction.from(await transaction.toJSON()).build({ client });
    return await this.#keypair.signTransaction(builtTransaction);
  };
  #signAndExecuteTransaction = async ({ transaction, signal, chain }) => {
    signal?.throwIfAborted();
    const client = this.#chainConfig[chain];
    if (!client) throw new Error(`Invalid chain "${chain}" specified.`);
    const parsedTransaction = Transaction.from(await transaction.toJSON());
    const bytes = await parsedTransaction.build({ client });
    const result = await this.#keypair.signAndExecuteTransaction({
      transaction: parsedTransaction,
      client
    });
    const tx = result.Transaction ?? result.FailedTransaction;
    return {
      bytes: toBase64(bytes),
      signature: tx.signatures[0],
      digest: tx.digest,
      effects: toBase64(tx.effects.bcs)
    };
  };
};
function createDAppKit({ autoConnect = true, networks, createClient, defaultNetwork = networks[0], enableBurnerWallet = false, slushWalletConfig, storage = getDefaultStorage(), storageKey = DEFAULT_STORAGE_KEY, walletInitializers = [] }) {
  const networkConfig = createNetworkConfig(networks, createClient);
  const stores = createStores({
    defaultNetwork,
    getClient: networkConfig.getClient
  });
  function getClient(network) {
    return network ? networkConfig.getClient(network) : stores.$currentClient.get();
  }
  storage ||= createInMemoryStorage();
  syncStateToStorage({
    stores,
    storageKey,
    storage
  });
  syncRegisteredWallets(stores);
  manageWalletConnection(stores);
  if (autoConnect) autoConnectWallet({
    networks,
    stores,
    storageKey,
    storage
  });
  registerAdditionalWallets([
    ...walletInitializers,
    ...enableBurnerWallet ? [unsafeBurnerWalletInitializer()] : [],
    ...slushWalletConfig !== null ? [slushWebWalletInitializer(slushWalletConfig)] : []
  ], {
    networks,
    getClient
  });
  return {
    networks,
    getClient,
    signTransaction: signTransactionCreator(stores),
    signAndExecuteTransaction: signAndExecuteTransactionCreator(stores),
    signPersonalMessage: signPersonalMessageCreator(stores),
    connectWallet: connectWalletCreator(stores, networks),
    disconnectWallet: disconnectWalletCreator(stores),
    switchAccount: switchAccountCreator(stores),
    switchNetwork: switchNetworkCreator(stores),
    stores: {
      $wallets: stores.$compatibleWallets,
      $connection: stores.$connection,
      $currentNetwork: readonlyType(stores.$currentNetwork),
      $currentClient: stores.$currentClient
    }
  };
}

// node_modules/.pnpm/@mysten+dapp-kit-react@1.0.1_@mysten+sui@2.2.0_@types+react@19.2.10_react@19.2.4_typescript@5.9.3/node_modules/@mysten/dapp-kit-react/dist/index.mjs
var DAppKitContext = (0, import_react2.createContext)(null);
function DAppKitProvider({ dAppKit, children }) {
  return (0, import_jsx_runtime.jsx)(DAppKitContext.Provider, {
    value: dAppKit,
    children
  });
}
function useDAppKit(dAppKit) {
  const contextValue = (0, import_react2.useContext)(DAppKitContext);
  if (dAppKit) return dAppKit;
  if (!contextValue) throw new Error("Could not find DAppKitContext. Ensure that you have set up the `DAppKitProvider` component.");
  return contextValue;
}
var ConnectButtonComponent = createComponent({
  react: React,
  tagName: "mysten-dapp-kit-connect-button",
  elementClass: DAppKitConnectButton
});
function ConnectButton({ instance, ...props }) {
  const dAppKit = useDAppKit(instance);
  return (0, import_jsx_runtime.jsx)(ConnectButtonComponent, {
    ...props,
    instance: dAppKit
  });
}
var ConnectModalComponent = createComponent({
  react: React,
  tagName: "mysten-dapp-kit-connect-modal",
  elementClass: DAppKitConnectModal
});
function ConnectModal({ instance, ...props }) {
  const dAppKit = useDAppKit(instance);
  return (0, import_jsx_runtime.jsx)(ConnectModalComponent, {
    ...props,
    instance: dAppKit
  });
}
function useWallets({ dAppKit } = {}) {
  return useStore(useDAppKit(dAppKit).stores.$wallets);
}
function useWalletConnection({ dAppKit } = {}) {
  return useStore(useDAppKit(dAppKit).stores.$connection);
}
function useCurrentAccount({ dAppKit } = {}) {
  return useWalletConnection({ dAppKit }).account;
}
function useCurrentWallet({ dAppKit } = {}) {
  return useWalletConnection({ dAppKit }).wallet;
}
function useCurrentClient({ dAppKit } = {}) {
  return useStore(useDAppKit(dAppKit).stores.$currentClient);
}
function useCurrentNetwork({ dAppKit } = {}) {
  return useStore(useDAppKit(dAppKit).stores.$currentNetwork);
}
export {
  ConnectButton,
  ConnectModal,
  DAppKitProvider,
  createDAppKit,
  getWalletUniqueIdentifier,
  useCurrentAccount,
  useCurrentClient,
  useCurrentNetwork,
  useCurrentWallet,
  useDAppKit,
  useWalletConnection,
  useWallets
};
//# sourceMappingURL=@mysten_dapp-kit-react.js.map
